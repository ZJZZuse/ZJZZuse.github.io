<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[rocket mq 核心概念]]></title>
    <url>%2F2019%2Frocketmq-Core-Concept%2F</url>
    <content type="text"><![CDATA[核心概念 根据上述模型，我们可以深入探讨有关消息传递系统设计的一些主题： 消费者并发 消费者热点问题 消费者负载平衡 消息路由器 连接多路复用 金丝雀部署（Canary Deployments） 生产者生产者将业务应用程序系统生成的消息发送给代理。RocketMQ提供多种发送范例：同步，异步和单向。 生产者组具有相同角色的生产者组合在一起。如果原始生产者在事务之后崩溃，则代理可以联系同一生产者组的不同生产者实例以提交或回滚事务。 警告：考虑到提供的生产者在发送消息方面足够强大，每个生产者组只允许一个实例，以避免不必要的生成器实例初始化。 消费者消费者从经纪人处获取消息并将其提供给应用程序。从用户应用的角度来看，提供了两种类型的消费者： PullConsumer拉动消费者主动从经纪人那里获取消息。一旦提取了批量消息，用户应用程序就会启动消费过程。 PushConsumer另一方面，推送消费者封装消息提取，消耗进度并维护其他内部工作，留下最终用户的回调接口以实现将在消息到达时执行。 消费者组与之前提到的生产者组类似，完全相同角色的消费者被组合在一起并命名为消费者组。 消费者群体是一个很好的概念，在消息消费方面实现负载平衡和容错目标非常容易。 警告：使用者组的使用者实例必须具有完全相同的主题订阅。 话题主题是生产者传递消息和消费者提取消息的类别。主题与生产者和消费者的关系非常松散。具体而言，主题可能有零个，一个或多个生成器向其发送消息;相反，制作人可以发送不同主题的消息。从消费者的角度来看，主题可以由零个，一个或多个消费者群体订阅。类似地，消费者组可以订阅一个或多个主题，只要该组的实例保持其订阅一致即可。 信息消息是要传递的信息。消息必须有一个主题，可以将其解释为您要发送给的邮件地址。消息还可以具有可选标记和额外的键 - 值对。例如，您可以为消息设置业务密钥，并在代理服务器上查找消息以诊断开发期间的问题。 消息队列主题被划分为一个或多个子主题“消息队列”。 标签标记，换句话说，子主题，为用户提供了额外的灵活性。对于标记，来自同一业务模块的具有不同目的的消息可以具有相同的主题和不同的标记。标签有助于保持代码的清晰和连贯，而标签也可以方便RocketMQ提供的查询系统。 经纪人（Broker）经纪人是RocketMQ系统的主要组成部分。它接收从生产者发送的消息，存储它们并准备处理来自消费者的拉取请求。它还存储与消息相关的元数据，包括消费者组，消耗进度偏移和主题/队列信息。 名称服务器名称服务器充当路由信息提供者。生产者/消费者客户查找主题以查找相应的代理列表。 消息模型 聚类（Clustering） 广播（Broadcasting） 消息顺序使用DefaultMQPushConsumer时，您可能决定按顺序或同时使用消息。 有顺序地 按顺序使用消息意味着消息的消费顺序与生产者为每个消息队列发送的顺序相同。如果您正在处理全局顺序是必需的方案，请确保您使用的主题只有一个消息队列。 警告：如果指定了有序消费，则消息消耗的最大并发数是消费者组订阅的消息队列数。 并发的 在并发使用消息时，消息消耗的最大并发性仅受为每个使用者客户端指定的线程池的限制。 警告：此模式下不再保证消息顺序。 转自：http://rocketmq.apache.org/docs/core-concept/]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>rocket mq</tag>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ简介]]></title>
    <url>%2F2019%2FRocketMQ-intro%2F</url>
    <content type="text"><![CDATA[动机在早期阶段，我们构建了基于ActiveMQ 5.x的分布式消息中间件（5.3之前）。我们的跨国业务将其用于异步通信，搜索，社交网络活动流，数据管道，甚至在其交易流程中。随着我们的贸易业务吞吐量的增加，源自我们的消息传递集群的压力也变得迫切。 为什么选择RocketMQ？根据我们的研究，随着使用的队列和虚拟主题的增加，ActiveMQ IO模块遇到了瓶颈。我们尽力通过节流，断路器或降级解决这个问题，但效果不佳。因此，我们开始关注当时流行的消息传递解决方案Kafka。不幸的是，Kafka无法满足我们的要求，特别是在低延迟和高可靠性方面，详见此处。 在这种情况下，我们决定发明一种新的消息传递引擎来处理更广泛的用例，从传统的发布/子场景到大容量实时零容量容错事务系统。我们相信这个解决方案可能是有益的，所以我们希望将它开源给社区。如今，有超过100家公司在其业务中使用RocketMQ的开源版本。我们还发布了基于RocketMQ的商业发行版，这是一种名为阿里巴巴ONS的PaaS产品。 下表演示了RocketMQ，ActiveMQ和Kafka（根据awesome-java的Apache最流行的消息传递解决方案）之间的比较： RocketMQ vs. ActiveMQ vs. Kafka请注意，本文档由RocketMQ团队撰写。虽然理想是技术和功能的无私比较，但作者的专业知识和偏见显然有利于RocketMQ。 下表是一个方便的快速参考，用于一目了然地发现RocketMQ及其最受欢迎的替代品之间的差异。 消息产品 客户端SDK 协议和规范 消息顺序 定时消息 批量消息 广播消息 消息过滤 服务器触发重新传递 消息存储 消息追溯 消息优先级 高可用性和故障转移 消息跟踪 配置 管理和操作工具 ActiveMQ Java，.NET，C ++等 推模型，支持OpenWire，STOMP，AMQP，MQTT，JMS 独家消费者或独家排队可以确保顺序 支持的 不支持 支持的 支持的 不支持 使用JDBC和高性能日志（如levelDB，kahaDB）支持非常快速的持久性 支持的 支持的 支持，根据存储，如果使用kahadb，则需要ZooKeeper服务器 不支持 默认配置为低级别，用户需要优化配置参数 支持的 卡夫卡 Java，Scala等 拉模型，支持TCP 确保在分区内对消息进行排序 不支持 支持，使用异步生产者 不支持 支持，您可以使用Kafka Streams过滤邮件 不支持 高性能文件存储 支持的偏移量表示 不支持 支持，需要ZooKeeper服务器 不支持 Kafka使用键值对格式进行配置。可以从文件或以编程方式提供这些值。 支持，使用terminal命令公开核心指标 RocketMQ Java，C ++，Go 拉模型，支持TCP，JMS，OpenMessaging 确保严格的消息排序，并可以优雅地扩展 支持的 支持，使用同步模式以避免消息丢失 支持的 支持的基于SQL92的属性过滤器表达式 支持的 高性能和低延迟的文件存储 支持的时间戳和偏移量2表示 不支持 支持的Master-Slave模型，没有其他套件 支持的 开箱即用，用户只需要注意几个配置 支持的富Web和终端命令，用于公开核心指标 转自：https://rocketmq.apache.org/docs/motivation/]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>mq</tag>
        <tag>RocketMQ</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发]]></title>
    <url>%2F2019%2Fconcurrence%2F</url>
    <content type="text"><![CDATA[原创翻译整理标注，转载请注明出处 并发Java平台的设计初衷就是为了支持并发编程，在Java编程语言和Java类库中提供基本的并发支持。从5.0版开始，Java平台还包含高级并发API。 进程和线程在并发编程中，有两个基本的执行单元：进程和线程。在Java编程语言中，并发编程主要涉及线程。 计算机系统通常具有许多活动进程和线程。即使在只有一个执行核心的系统中也是如此，因此在任何给定时刻只有一个线程实际执行。通过称为时间切片的OS功能，在进程和线程之间共享单个核心的处理时间。 对于具有多个处理器或具有多个执行核心的处理器的计算机系统来说，处理更加自然。这极大地增强了系统并发执行进程和线程的能力 - 但即使在没有多个处理器或执行核心的简单系统上也可以实现并发。进程 进程具有自包含的执行环境。进程通常具有完整的私有基本运行时资源集; 特别是，每个进程都有自己的内存空间。 进程通常被视为程序或应用程序的同义词。但是，用户看到的单个应用程序实际上可能是一组协作进程。为了促进进程之间的通信，大多数操作系统都支持进程间通信（IPC）资源，例如管道和套接字。IPC不仅用于同一系统上的进程之间的通信，而且还用于不同系统上的进程。 Java虚拟机的大多数实现都作为单个进程运行。Java应用程序可以使用ProcessBuilder对象创建其他进程 线程 线程有时被称为轻量级进程。进程和线程都提供执行环境，但创建新线程所需的资源更少。 线程存在于进程中 - 每个进程至少有一个进程。线程共享进程的资源，包括内存和打开文件。这使得有效但可能有问题的通信成为可能。 多线程执行是Java平台的基本特性。每个应用程序至少有一个线程 - 或几个，如果你计算“系统”线程，它们执行内存管理和信号处理等操作。但是从应用程序员的角度来看，你只从一个线程开始，称为主线程。该线程具有创建其他线程的能力。 线程对象每个线程都与该类的实例相关联 Thread。使用Thread对象创建并发应用程序有两种基本策略。 要直接控制线程创建和管理，只需Thread在应用程序每次启动异步任务时进行实例化。 要从应用程序的其余部分抽象线程管理，请将应用程序的任务传递给执行程序。 定义和启动线程创建线程的两个方法： 提供一个Runnable对象。该 Runnable接口定义了一个方法，run，意在包含在线程执行的代码。该Runnable对象被传递给Thread构造函数，如 HelloRunnable示例所示： 1234567891011public class HelloRunnable implements Runnable &#123; public void run() &#123; System.out.println(&quot;Hello from a thread!&quot;); &#125; public static void main(String args[]) &#123; (new Thread(new HelloRunnable())).start(); &#125;&#125; 拓展Thread。在Thread类本身实现了Runnable，虽然它的run方法不起作用。应用程序可以子类化Thread，提供自己的实现run，如 HelloThread示例中所示： 1234567891011public class HelloThread extends Thread &#123; public void run() &#123; System.out.println(&quot;Hello from a thread!&quot;); &#125; public static void main(String args[]) &#123; (new HelloThread()).start(); &#125;&#125; 请注意，两个示例都会调用Thread.start以启动新线程。 你应该使用哪种？第一个使用Runnable对象更为通用，因为该Runnable对象可以继承一个类以外的类Thread。第二个在简单的应用程序中更容易使用，但受到任务类必须是后代的限制Thread。这里重点介绍第一种方法，该方法将Runnable任务与Thread执行任务的对象分开。这种方法不仅更灵活，而且适用于后面介绍的高级线程管理API。 Thread类定义了大量的线程管理的方法。这些static方法包括提供有关调用方法的线程的信息或影响其状态的方法。从管理线程和Thread对象所涉及的其他线程调用其他方法。我们将在以下部分中研究其中一些方法。 暂停执行与睡眠Thread.sleep可以使当前线程暂停执行。这是使处理器时间可用于应用程序的其他线程或其他应用程序的有效方法。 提供了两个重载版本sleep：一个指定睡眠时间为毫秒，另一个为纳秒。但是，这些睡眠时间并不保证精确，因为它们受到底层操作系统的限制。此外，睡眠周期可以通过中断终止，我们将在后面看到。在任何情况下，您都不能假设调用sleep将在指定的时间段内暂停线程。 该 SleepMessages示例用于sleep以四秒为间隔打印消息： 1234567891011121314151617181920public class SleepMessages &#123; public static void main(String args[]) throws InterruptedException &#123; String importantInfo[] = &#123; &quot;Mares eat oats&quot;, &quot;Does eat oats&quot;, &quot;Little lambs eat ivy&quot;, &quot;A kid will eat ivy too&quot; &#125;; for (int i = 0; i &lt; importantInfo.length; i++) &#123; //Pause for 4 seconds Thread.sleep(4000); //Print a message System.out.println(importantInfo[i]); &#125; &#125;&#125; 请注意，main声明它throws InterruptedException。当另一个线程在sleep活动时中断当前线程时，抛出此异常。由于此程序尚未定义另一个引起中断的线程，因此无需捕获InterruptedException。 中断一个中断是一个指示线程它应该终止它在做的和将要做的。由程序员决定线程如何响应，但一般是终止线程。 通过调用interrupt可以进行中断。为使中断机制正常工作，被中断的线程必须支持自己的中断。 支持中断 线程如何支持自己的中断？如果线程经常调用抛出InterruptedException的方法，它只是简单返回。例如，假设示例中SleepMessages的run方法中Runnable。然后可以按如下方式修改以支持中断： 1234567891011for (int i = 0; i &lt; importantInfo.length; i++) &#123; // Pause for 4 seconds try &#123; Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; // We&apos;ve been interrupted: no more messages. return; &#125; // Print a message System.out.println(importantInfo[i]);&#125; 许多方法抛出InterruptedException，例如sleep，设计为取消当前操作并在收到中断时立即返回。 如果一个线程长时间没有调用抛出InterruptedException的方法怎么办？那么它必须定期调用Thread.interrupted，如果收到中断则返回。例如： 1234567for (int i = 0; i &lt; inputs.length; i++) &#123; heavyCrunch(inputs[i]); if (Thread.interrupted()) &#123; // We&apos;ve been interrupted: no more crunching. return; &#125;&#125; 在这个简单的例子中，代码只是测试中断并退出线程（如果收到）。在更复杂的应用程序中，更可能会抛出有意义的InterruptedException： 123if (Thread.interrupted()) &#123; throw new InterruptedException();&#125; 这允许中断处理集中在一个catch子句中。 中断状态标志 中断机制使用称为中断状态的内部标志来实现。调用Thread.interrupt设置此标志。当线程通过调用静态方法检查中断时Thread.interrupted，中断状态被清除。非静态isInterrupted方法（一个线程用于查询另一个线程的中断状态）不会更改中断状态标志。 按照惯例，任何通过抛出InterruptedException都会清除中断状态。但是，通过另一个线程调用interrupt，立即再次设置中断状态。 Joins该join方法允许一个线程等待另一个线程的完成。如果t是Thread其线程当前正在执行的对象，t.join（）;导致当前线程暂停执行，直到t线程终止。重载join允许程序员指定等待期。但是，如同sleep，join取决于操作系统的计时，所以你不应该假设join只要你指定就等待。 就像sleep，join通过退出来响应中断InterruptedException。 SimpleThreads示例以下示例汇总了本节的一些概念。 SimpleThreads由两个线程组成。第一个是每个Java应用程序都有的主线程。主线程从Runnable对象创建一个新线程MessageLoop，并等待它完成。如果MessageLoop线程需要很长时间才能完成，主线程会中断它。 该MessageLoop线程打印出一系列消息。如果在打印完所有消息之前中断，则MessageLoop线程会打印一条消息并退出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//@see com.example.zjz.javaconcurrence.demo.SimpleThreadspublic class SimpleThreads &#123; // Display a message, preceded by // the name of the current thread static void threadMessage(String message) &#123; String threadName = Thread.currentThread().getName(); System.out.format(&quot;%s: %s%n&quot;, threadName, message); &#125; private static class MessageLoop implements Runnable &#123; public void run() &#123; String importantInfo[] = &#123; &quot;Mares eat oats&quot;, &quot;Does eat oats&quot;, &quot;Little lambs eat ivy&quot;, &quot;A kid will eat ivy too&quot; &#125;; try &#123; for (int i = 0; i &lt; importantInfo.length; i++) &#123; // Pause for 4 seconds Thread.sleep(4000); // Print a message threadMessage(importantInfo[i]); &#125; &#125; catch (InterruptedException e) &#123; threadMessage(&quot;I wasn&apos;t done!&quot;); &#125; &#125; &#125; public static void main(String args[]) throws InterruptedException &#123; // Delay, in milliseconds before // we interrupt MessageLoop // thread (default one hour). long patience = 1000 * 60 * 60; // If command line argument // present, gives patience // in seconds. if (args.length &gt; 0) &#123; try &#123; patience = Long.parseLong(args[0]) * 1000; &#125; catch (NumberFormatException e) &#123; System.err.println(&quot;Argument must be an integer.&quot;); System.exit(1); &#125; &#125; threadMessage(&quot;Starting MessageLoop thread&quot;); long startTime = System.currentTimeMillis(); Thread t = new Thread(new MessageLoop()); t.start(); threadMessage(&quot;Waiting for MessageLoop thread to finish&quot;); // loop until MessageLoop // thread exits while (t.isAlive()) &#123; threadMessage(&quot;Still waiting...&quot;); // Wait maximum of 1 second // for MessageLoop thread // to finish. t.join(1000); if (((System.currentTimeMillis() - startTime) &gt; patience) &amp;&amp; t.isAlive()) &#123; threadMessage(&quot;Tired of waiting!&quot;); t.interrupt(); // Shouldn&apos;t be long now // -- wait indefinitely t.join(); &#125; &#125; threadMessage(&quot;Finally!&quot;); &#125;&#125; 同步线程主要通过共享对字段的访问和引用字段引用的对象进行通信。这种通信形式非常有效，但可能出现两种错误：线程干扰和内存一致性错误。防止这些错误所需的工具是同步。 但是，同步可能会引入线程竞争，当两个或多个线程同时尝试访问同一资源并导致Java运行时更慢地执行一个或多个线程，甚至暂停执行时，会发生线程竞争。 饥饿和活锁是线程竞争的形式。 本节包括以下主题： 线程干扰 描述了当多个线程访问共享数据时如何引入错误。 内存一致性错误 描述了由共享内存的不一致视图导致的错误。 同步方法 描述了一种简单的习惯用法，可以有效地防止线程干扰和内存一致性错误。 隐式锁定和同步 描述了更通用的同步习惯用法，并描述了同步基于隐式锁定的方式。 Atomic Access 讨论了其他线程无法干扰的操作的一般概念。 线程干扰（Thread Interference）考虑一个叫做的简单类 Counter 12345678910111213141516class Counter &#123; private int c = 0; public void increment() &#123; c++; &#125; public void decrement() &#123; c--; &#125; public int value() &#123; return c; &#125;&#125; Counter的设计是为了每次调用increment都会c加1 ，每次调用decrement都会从中减去1 。但是，如果Counter从多个线程引用对象，则线程之间的干扰可能会阻止这种情况按预期发生。 当两种操作，在不同的线程运行，但作用于同一数据的干扰情况。这意味着这两个操作由多个步骤组成，并且步骤序列重叠。 Counter对于交错实例的操作似乎不太可能，因为两个操作c都是单个简单的语句。但是，即使是简单的语句也可以由虚拟机转换为多个步骤。我们不会检查虚拟机采取的具体步骤 - 只需知道单个表达式c**可以分解为三个步骤： 检索当前值c。 将检索的值增加1。 将增加的值存储回来c。 表达式c–可以以相同的方式分解，除了第二步减少而不是增量。 假设线程A increment在线程B调用的同时调用decrement。如果初始值为cis 0，则它们的交错操作可能遵循以下顺序： 线程A：检索c。 线程B：检索c。 线程A：增加检索值; 结果是1。 线程B：减少检索值; 结果是-1。 线程A：将结果存储在c中; c现在是1。 线程B：将结果存储在c中; c现在是-1。 线程A的结果丢失，被线程B覆盖。这种特殊的交错只是一种可能性。在不同的情况下，可能是线程B的结果丢失，或者根本没有错误。因为它们是不可预测的，所以难以检测和修复线程干扰错误。 内存一致性错误（Memory Consistency Errors）当不同的线程具有应该是相同数据的不一致视图时，会发生内存一致性错误。内存一致性错误的原因很复杂，超出了本教程的范围。幸运的是，程序员不需要详细了解这些原因。所需要的只是避免它们的策略。 避免内存一致性错误的关键是理解先发生关系（happens-before relationship）。这种关系只是保证一个特定语句的内存写入对另一个特定语句可见。要查看此内容，请考虑以下示例。假设int定义并初始化了一个简单字段： 1int counter = 0; 该counter字段在两个线程A和B之间共享。假设线程A递增counter： 1counter++; 然后，不久之后，线程B打印出来counter： 1System.out.println(counter); 如果两个语句已在同一个线程中执行，则可以安全地假设打印出的值为“1”。但是如果这两个语句是在不同的线程中执行的，那么打印出的值可能是“0”，因为不能保证线程A的更改counter对于线程B是可见的 - 除非程序员在这些之间建立了先发生关系。两个陈述。 有几种行为可以创造先发生过的关系。其中之一是同步，我们将在以下部分中看到。 我们已经看到了两种创造前发生关系的行为。 当一个语句调用时Thread.start，与该语句有一个happens-before关系的每个语句也与新线程执行的每个语句都有一个happens-before关系。新线程可以看到导致创建新线程的代码的影响。 当一个线程终止并导致Thread.join另一个线程返回时，终止线程执行的所有语句与成功连接后的所有语句都有一个happens-before关系。现在，执行连接的线程可以看到线程中代码的效果。 有关创建先发生关系的操作列表，请参阅java.util.concurrent。 同步方法Java编程语言提供了两种基本的同步习惯用法：synchronized方法和synchronized语句。下两节将介绍两个同步语句中较为复杂的语句。本节介绍同步方法。 要使方法同步，只需将synchronized关键字添加到其声明： 123456789101112131415public class SynchronizedCounter &#123; private int c = 0; public synchronized void increment() &#123; c++; &#125; public synchronized void decrement() &#123; c--; &#125; public synchronized int value() &#123; return c; &#125;&#125; 如果count是实例SynchronizedCounter，则使这些方法同步有两个影响： 首先，对同一对象的两个同步方法的调用不可能进行交错。当一个线程正在为对象执行同步方法时，所有其他线程调用同一对象的同步方法（暂停执行）直到第一个线程完成对象。 其次，当同步方法退出时，它会自动与同一对象的同步方法的任何后续调用建立**先发生关系**。这可以保证对所有线程都可以看到对象状态的更改。请注意，构造函数无法同步 - 使用synchronized带有构造函数的关键字是语法错误。同步构造函数没有意义，因为只有创建对象的线程在构造时才能访问它。 警告： 构造将在线程之间共享的对象时，要非常小心，对对象的引用不会过早“泄漏”。例如，假设您要维护一个包含每个类实例的List调用instances。您可能想要将以下行添加到构造函数中：1instances.add(this); 但是其他线程可以instances在构造对象完成之前用来访问对象。 同步方法支持一种简单的策略来防止线程干扰和内存一致性错误：如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过synchronized方法完成的。（一个重要的例外：final在构造对象之后无法修改的字段，一旦构造了对象，就可以通过非同步方法安全地读取）这种策略是有效的，但是可能会带来性能问题。 内部锁定和同步同步是围绕称为内部锁或监视器锁的内部实体构建的。（API规范通常将此实体简称为“监视器（monitor）”。）内部锁在同步的两个方面都发挥作用：强制对对象状态进行独占访问，并建立对可见性至关重要的先发生关系（happens-before relationships）。 每个对象都有一个与之关联的内部锁。按照惯例，需要对对象字段进行独占和一致访问的线程必须在访问对象之前获取对象的内部锁，然后在完成它们时释放内部锁。据说一个线程在获得锁定和释放锁定之间拥有内在锁定。只要一个线程拥有一个内部锁，没有其他线程可以获得相同的锁。另一个线程在尝试获取锁时将阻塞。 当线程释放内部锁时，在该操作与同一锁的任何后续获取之间建立先发生关系。 锁定同步方法 当线程调用synchronized方法时，它会自动获取该方法对象的内部锁，并在方法返回时释放它。即使返回是由未捕获的异常引起的，也会发生锁定释放。 您可能想知道在调用静态同步方法时会发生什么，因为静态方法与类关联，而不是与对象关联。在这种情况下，线程获取Class与类关联的对象的内部锁。因此，对类的静态字段的访问由与该类的任何实例的锁不同的锁控制。 同步语句 创建同步代码的另一种方法是使用synchronized语句。与synchronized方法不同，synchronized语句必须指定提供内部锁的对象： 1234567public void addName(String name) &#123; synchronized(this) &#123; lastName = name; nameCount++; &#125; nameList.add(name);&#125; 在该示例中，addName方法需要同步变化lastName和nameCount，还需要避免的其他对象的方法同步调用。（从同步代码调用其他对象的方法可能会产生在Liveness一节中描述的问题。）如果没有synchronized语句，则必须有一个单独的，不同步的方法，仅用于调用nameList.add。 同步语句对于通过细粒度同步 提高并发性也很有用。例如，假设class MsLunch有两个实例字段，c1并且c2从不一起使用。必须同步这些字段的所有更新，但没有理由阻止c1的更新与c2的更新交错 - 这样做会通过创建不必要的阻塞来减少并发性。this我们创建两个对象仅用于提供锁，而不是使用同步方法或以其他方式使用与之关联的锁。 123456789101112131415161718public class MsLunch &#123; private long c1 = 0; private long c2 = 0; private Object lock1 = new Object(); private Object lock2 = new Object(); public void inc1() &#123; synchronized(lock1) &#123; c1++; &#125; &#125; public void inc2() &#123; synchronized(lock2) &#123; c2++; &#125; &#125;&#125; 谨慎使用。您必须绝对确保对受影响字段的访问进行交错是否安全。 可重入同步（Reentrant Synchronization） 回想一下，线程无法获取另一个线程拥有的锁。但是，一个线程可以获取它已经拥有的锁。允许线程多次获取相同的锁可启用重入同步。这描述了一种情况，其中同步代码直接或间接地调用也包含同步代码的方法，并且两组代码使用相同的锁。在没有可重入同步的情况下，同步代码必须采取许多额外的预防措施，以避免线程导致自身阻塞。 原子访问在编程中，原子动作是一次有效发生的动作。原子动作不能在中间停止：它要么完全发生，要么根本不发生。在动作完成之前，原子动作的副作用是不可见的。 我们已经看到增量表达式，例如c++，没有描述原子动作。即使非常简单的表达式也可以定义可以分解为其他操作的复杂操作。但是，您可以确定下列原子操作： 读取和写入对于引用变量和大多数原始变量（除了long和double之外的所有类型）都是原子的。 读取和写入对于声明的所有变量volatile（包括 long和double变量）都是原子的。 原子动作不能交错，因此可以使用它们而不必担心线程干扰。但是，这并不能消除所有同步原子操作的需要，因为仍然可能存在内存一致性错误。使用volatile变量可以降低内存一致性错误的风险，因为对volatile变量的任何写入都会建立与之后读取同一变量的先发生关系。这意味着对volatile变量的更改始终对其他线程可见。更重要的是，它还意味着当一个线程读取一个volatile变量时，它不仅会看到最新的变化volatile，而且还会看到导致变化的代码的副作用。 使用简单的原子变量访问比通过同步代码访问这些变量更有效，但程序员需要更加小心以避免内存一致性错误。额外的努力是否值得取决于应用程序的大小和复杂性。 包中的某些类 java.util.concurrent提供了不依赖于同步的原子方法。 活跃度（Liveness） 并发应用程序及时执行的能力被称为其活跃性。本节描述了最常见的活动问题，即死锁，并继续简要描述其他两个活动问题，饥饿和活锁。 死锁死锁描述了两个或多个线程永远被阻塞，等待彼此的情况。这是一个例子。 阿方斯和加斯顿是朋友，他们都很有礼貌。严格的礼貌规则是，当你向朋友鞠躬时，你必须保持鞠躬，直到你的朋友有机会还礼。不幸的是，这条规则没有考虑到两个朋友可能同时互相鞠躬的可能性。这个示例应用程序 Deadlock模拟了这种可能性： 123456789101112131415161718192021222324252627282930313233343536//@see com.example.zjz.javaconcurrence.demo.Deadlockpublic class Deadlock &#123; static class Friend &#123; private final String name; public Friend(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; public synchronized void bow(Friend bower) &#123; System.out.format(&quot;%s: %s&quot; + &quot; has bowed to me!%n&quot;, this.name, bower.getName()); bower.bowBack(this); &#125; public synchronized void bowBack(Friend bower) &#123; System.out.format(&quot;%s: %s&quot; + &quot; has bowed back to me!%n&quot;, this.name, bower.getName()); &#125; &#125; public static void main(String[] args) &#123; final Friend alphonse = new Friend(&quot;Alphonse&quot;); final Friend gaston = new Friend(&quot;Gaston&quot;); new Thread(new Runnable() &#123; public void run() &#123; alphonse.bow(gaston); &#125; &#125;).start(); new Thread(new Runnable() &#123; public void run() &#123; gaston.bow(alphonse); &#125; &#125;).start(); &#125;&#125; 当Deadlock运行时，这是非常有可能的是，当他们尝试调用两个线程将被阻塞bowBack。这两个块都不会结束，因为每个线程都在等待另一个线程退出bow。 饥饿和活锁饥饿和活锁没有死锁常见，但仍然是每个并发软件设计者可能遇到的问题。 饥饿 Starvation描述了一种情况，即线程无法定期访问共享资源，并且无法运行。当“贪婪”线程使共享资源长时间不可用时会发生这种情况。例如，假设一个对象提供了一个通常需要很长时间才能返回的同步方法。如果一个线程经常调用此方法，则通常还需要阻止对同一对象进行频繁同步访问的其他线程。 活锁 线程通常用于响应另一个线程的操作。如果另一个线程的操作也是对另一个线程的操作的响应，则可能导致活锁。与死锁一样，活锁线程无法取得进一步进展。但是，线程没有被阻塞- 它们只是太忙于相互响应以恢复工作。这相当于两个试图在走廊里互相通过的人：Alphonse向左移动让Gaston通过，而Gaston向右移动让Alphonse通过。看到他们仍在相互阻挡，Alphone向右移动，而Gaston向左移动。他们还在互相阻挡，所以…… 守卫块（Guarded Blocks）线程通常必须协调他们的行为。最常见的协调习语是守卫块。这样的块开始于在块可以继续之前轮询必须为真的条件。要正确执行此操作，需要执行许多步骤。 例如，假设guardedJoy一个方法joy在另一个线程设置共享变量之前不得继续。理论上，这种方法可以简单地循环直到满足条件，但该循环是浪费的，因为它在等待时连续执行。 123456public void guardedJoy() &#123; // Simple loop guard. Wastes // processor time. Don&apos;t do this! while(!joy) &#123;&#125; System.out.println(&quot;Joy has been achieved!&quot;);&#125; 一个更有效的守卫调用 Object.wait暂停当前线程。在wait另一个线程发出可能发生某些特殊事件的通知之前，调用不会返回 - 尽管不一定是此线程正在等待的事件： 12345678910public synchronized void guardedJoy() &#123; // This guard only loops once for each special event, which may not // be the event we&apos;re waiting for. while(!joy) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123;&#125; &#125; System.out.println(&quot;Joy and efficiency have been achieved!&quot;);&#125; 注意： wait始终在测试等待条件的循环内调用。不要假设中断是针对您正在等待的特定条件，或者条件仍然是真的。 像许多暂停执行的方法一样，wait可以抛出InterruptedException。在这个例子中，我们可以忽略该异常 - 我们只关心它的值joy。 为什么这个版本guardedJoy要同步？假设d是我们用来调用的对象wait。当线程调用时d.wait，它必须拥有内部锁d- 否则会引发错误。wait在synchronized方法中调用是获取内部锁的简单方法。 当wait被调用时，线程释放锁，并暂停执行。在将来的某个时间，另一个线程将获取相同的锁并调用 Object.notifyAll，通知等待该锁的所有线程发生了重要的事情： 1234public synchronized notifyJoy() &#123; joy = true; notifyAll();&#125; 在第二个线程释放锁之后的一段时间，第一个线程重新获取锁并通过从调用返回来恢复wait。 注意： 有第二种通知方法notify，可以唤醒单个线程。因为notify不允许您指定被唤醒的线程，所以它仅在大规模并行应用程序中有用 - 即具有大量线程的程序，所有程序都执行类似的工作。在这样的应用程序中，您不关心哪个线程被唤醒。 让我们使用受保护的块来创建Producer-Consumer应用程序。这种应用程序在两个线程之间共享数据：生成器，创建数据，以及使用它的消费者。两个线程使用共享对象进行通信。协调是必不可少的：消费者线程不得在生产者线程交付之前尝试检索数据，并且如果消费者未检索旧数据，则生产者线程不得尝试传递新数据。 在此示例中，数据是一系列文本消息，通过以下类型的对象共享 Drop： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Drop &#123; // Message sent from producer // to consumer. private String message; // True if consumer should wait // for producer to send message, // false if producer should wait for // consumer to retrieve message. private boolean empty = true; public synchronized String take() &#123; // Wait until message is // available. while (empty) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123;&#125; &#125; // Toggle status. empty = true; // Notify producer that // status has changed. notifyAll(); return message; &#125; public synchronized void put(String message) &#123; // Wait until message has // been retrieved. while (!empty) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123;&#125; &#125; // Toggle status. empty = false; // Store message. this.message = message; // Notify consumer that status // has changed. notifyAll(); &#125;&#125; 定义的生产者线程 Producer发送一系列熟悉的消息。字符串“DONE”表示已发送所有消息。为了模拟真实世界应用程序的不可预测性，生产者线程暂停消息之间的随机间隔。 1234567891011121314151617181920212223242526272829import java.util.Random;public class Producer implements Runnable &#123; private Drop drop; public Producer(Drop drop) &#123; this.drop = drop; &#125; public void run() &#123; String importantInfo[] = &#123; &quot;Mares eat oats&quot;, &quot;Does eat oats&quot;, &quot;Little lambs eat ivy&quot;, &quot;A kid will eat ivy too&quot; &#125;; Random random = new Random(); for (int i = 0; i &lt; importantInfo.length; i++) &#123; drop.put(importantInfo[i]); try &#123; Thread.sleep(random.nextInt(5000)); &#125; catch (InterruptedException e) &#123;&#125; &#125; drop.put(&quot;DONE&quot;); &#125;&#125; 定义的消费者线程 Consumer只是检索消息并将其打印出来，直到它检索到“DONE”字符串。该线程也会暂停随机间隔。 123456789101112131415161718192021import java.util.Random;public class Consumer implements Runnable &#123; private Drop drop; public Consumer(Drop drop) &#123; this.drop = drop; &#125; public void run() &#123; Random random = new Random(); for (String message = drop.take(); ! message.equals(&quot;DONE&quot;); message = drop.take()) &#123; System.out.format(&quot;MESSAGE RECEIVED: %s%n&quot;, message); try &#123; Thread.sleep(random.nextInt(5000)); &#125; catch (InterruptedException e) &#123;&#125; &#125; &#125;&#125; 最后，这里是定义的主线程 ProducerConsumerExample，用于启动生产者和消费者线程。 1234567public class ProducerConsumerExample &#123; public static void main(String[] args) &#123; Drop drop = new Drop(); (new Thread(new Producer(drop))).start(); (new Thread(new Consumer(drop))).start(); &#125;&#125; 注： 该Drop被写入以证明保护块。为避免重新发明轮子，请在尝试编写自己的数据共享对象之前检查Java Collections Framework中的现有数据结构 。 不可变对象如果一个对象的状态在构造后不能改变，则该对象被认为是不可变的。最大程度上依赖不可变对象被广泛接受为创建简单，可靠代码的合理策略。 不可变对象在并发应用程序中特别有用。由于它们不能改变状态，因此它们不会被线程干扰破坏或在不一致状态下被观察到。 程序员通常不愿意使用不可变对象，因为他们担心创建新对象的成本而不是更新对象。对象创建的影响经常被高估，并且可以通过与不可变对象相关联的一些效率来抵消。这些包括由于垃圾收集而减少的开销，以及消除保护可变对象免于损坏所需的代码。 以下小节采用其实例可变的类，并从中派生出具有不可变实例的类。通过这样做，它们为这种转换提供了一般规则，并展示了不可变对象的一些优点。 同步类示例该类 SynchronizedRGB定义了表示颜色的对象。每个对象将颜色表示为代表主要颜色值的三个整数和一个给出颜色名称的字符串。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class SynchronizedRGB &#123; // Values must be between 0 and 255. private int red; private int green; private int blue; private String name; private void check(int red, int green, int blue) &#123; if (red &lt; 0 || red &gt; 255 || green &lt; 0 || green &gt; 255 || blue &lt; 0 || blue &gt; 255) &#123; throw new IllegalArgumentException(); &#125; &#125; public SynchronizedRGB(int red, int green, int blue, String name) &#123; check(red, green, blue); this.red = red; this.green = green; this.blue = blue; this.name = name; &#125; public void set(int red, int green, int blue, String name) &#123; check(red, green, blue); synchronized (this) &#123; this.red = red; this.green = green; this.blue = blue; this.name = name; &#125; &#125; public synchronized int getRGB() &#123; return ((red &lt;&lt; 16) | (green &lt;&lt; 8) | blue); &#125; public synchronized String getName() &#123; return name; &#125; public synchronized void invert() &#123; red = 255 - red; green = 255 - green; blue = 255 - blue; name = &quot;Inverse of &quot; + name; &#125;&#125; SynchronizedRGB必须小心使用，以免被发现处于不一致状态。例如，假设一个线程执行以下代码： 12345SynchronizedRGB color = new SynchronizedRGB(0, 0, 0, &quot;Pitch Black&quot;);...int myColorInt = color.getRGB(); //Statement 1String myColorName = color.getName(); //Statement 2 如果另一个线程color.set在语句1之后但在语句2之前调用，则其值myColorInt将与值不匹配myColorName。为了避免这种结果，必须将这两个语句绑定在一起： 1234synchronized (color) &#123; int myColorInt = color.getRGB(); String myColorName = color.getName();&#125; 这种不一致性只适用于可变对象 - 对于不可变版本的SynchronizedRGB来说，它不会成为问题。 一种定义不可变对象的策略以下规则定义了用于创建不可变对象的简单策略。并非所有记录为“不可变”的类都遵循这些规则。这并不一定意味着这些类的创造者是草率的 - 他们可能有充分的理由相信他们的类实例在建造后永远不会改变。但是，这种策略需要复杂的分析，不适合初学者。 不要提供“setter”方法 - 修改字段引用的字段或对象的方法。 使所有字段final和private。 不允许子类重写方法。最简单的方法是将类声明为final。更复杂的方法是private在工厂方法中构造构造函数和构造实例。 如果实例字段包含对可变对象的引用，则不允许更改这些对象： 不要提供修改可变对象的方法。 不要共享对可变对象的引用。永远不要存储对传递给构造函数的外部可变对象的引用; 如有必要，创建副本并存储对副本的引用。同样，必要时创建内部可变对象的副本，以避免在方法中返回原始对象。 将此策略应用于SynchronizedRGB以下步骤： 这个类中有两个setter方法。第一个，set任意转换对象，并且在类的不可变版本中没有位置。第二个，invert可以通过让它创建一个新对象而不是修改现有对象来进行调整。 所有领域都已经存在private; 他们进一步被认定为final。 类本身已声明final。 只有一个字段引用一个对象，该对象本身是不可变的。因此，不需要防止改变“包含的”可变对象的状态的保护措施。在这些变化之后，我们有 ImmutableRGB： 123456789101112131415161718192021222324252627282930313233343536373839404142434445final public class ImmutableRGB &#123; // Values must be between 0 and 255. final private int red; final private int green; final private int blue; final private String name; private void check(int red, int green, int blue) &#123; if (red &lt; 0 || red &gt; 255 || green &lt; 0 || green &gt; 255 || blue &lt; 0 || blue &gt; 255) &#123; throw new IllegalArgumentException(); &#125; &#125; public ImmutableRGB(int red, int green, int blue, String name) &#123; check(red, green, blue); this.red = red; this.green = green; this.blue = blue; this.name = name; &#125; public int getRGB() &#123; return ((red &lt;&lt; 16) | (green &lt;&lt; 8) | blue); &#125; public String getName() &#123; return name; &#125; public ImmutableRGB invert() &#123; return new ImmutableRGB(255 - red, 255 - green, 255 - blue, &quot;Inverse of &quot; + name); &#125;&#125; 高级并发对象到目前为止，本课程重点关注从一开始就是Java平台一部分的低级API。这些API适用于非常基本的任务，但更高级的任务需要更高级别的构建块。对于充分利用当今多处理器和多核系统的大规模并发应用程序尤其如此。 在本节中，我们将介绍Java平台5.0版中引入的一些高级并发功能。大多数这些功能都在新java.util.concurrent包中实现。Java Collections Framework中还有新的并发数据结构。 锁对象支持锁定习惯用法，简化了许多并发应用程序。 执行程序定义用于启动和管理线程的高级API。提供的执行程序实现提供java.util.concurrent适用于大规模应用程序的线程池管理。 并发集合使管理大量数据更容易，并且可以大大减少同步需求。 原子变量具有最小化同步的功能，有助于避免内存一致性错误。 ThreadLocalRandom （在JDK 7中）提供了从多个线程有效生成伪随机数。 锁对象（Lock Objects）同步代码依赖于一种简单的可重入锁定。这种锁易于使用，但有许多限制。java.util.concurrent.locks包装支持更复杂的锁定习语 。我们不会详细介绍这个包，而是将重点放在它最基本的接口上 Lock。 Lock对象的工作方式与同步代码使用的隐式锁非常相似。与隐式锁一样，一次只有一个线程可以拥有一个Lock对象。Lock对象还通过其关联Condition对象支持wait/notify机制。 Lock对象相对于隐式锁定的最大优点是它们能够退出获取锁定的尝试。tryLock如果锁定立即不可用或超时到期之前（如果指定），则该方法退出。lockInterruptibly如果另一个线程在获取锁之前发送中断，则该方法退出。 让我们使用Lock对象来解决我们在Liveness中看到的死锁问题。当朋友即将鞠躬时，阿方斯和加斯顿已经训练自己注意到了。我们通过要求我们的Friend对象必须在继续执行弓之前获取两个参与者的锁来模拟这种改进。以下是改进模型的源代码 Safelock。为了证明这个习语的多样性，我们假设阿尔方斯和加斯顿如此迷恋他们新发现的安全鞠躬能力，他们不能停止相互鞠躬： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.Random;public class Safelock &#123; static class Friend &#123; private final String name; private final Lock lock = new ReentrantLock(); public Friend(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; public boolean impendingBow(Friend bower) &#123; Boolean myLock = false; Boolean yourLock = false; try &#123; myLock = lock.tryLock(); yourLock = bower.lock.tryLock(); &#125; finally &#123; if (! (myLock &amp;&amp; yourLock)) &#123; if (myLock) &#123; lock.unlock(); &#125; if (yourLock) &#123; bower.lock.unlock(); &#125; &#125; &#125; return myLock &amp;&amp; yourLock; &#125; public void bow(Friend bower) &#123; if (impendingBow(bower)) &#123; try &#123; System.out.format(&quot;%s: %s has&quot; + &quot; bowed to me!%n&quot;, this.name, bower.getName()); bower.bowBack(this); &#125; finally &#123; lock.unlock(); bower.lock.unlock(); &#125; &#125; else &#123; System.out.format(&quot;%s: %s started&quot; + &quot; to bow to me, but saw that&quot; + &quot; I was already bowing to&quot; + &quot; him.%n&quot;, this.name, bower.getName()); &#125; &#125; public void bowBack(Friend bower) &#123; System.out.format(&quot;%s: %s has&quot; + &quot; bowed back to me!%n&quot;, this.name, bower.getName()); &#125; &#125; static class BowLoop implements Runnable &#123; private Friend bower; private Friend bowee; public BowLoop(Friend bower, Friend bowee) &#123; this.bower = bower; this.bowee = bowee; &#125; public void run() &#123; Random random = new Random(); for (;;) &#123; try &#123; Thread.sleep(random.nextInt(10)); &#125; catch (InterruptedException e) &#123;&#125; bowee.bow(bower); &#125; &#125; &#125; public static void main(String[] args) &#123; final Friend alphonse = new Friend(&quot;Alphonse&quot;); final Friend gaston = new Friend(&quot;Gaston&quot;); new Thread(new BowLoop(alphonse, gaston)).start(); new Thread(new BowLoop(gaston, alphonse)).start(); &#125;&#125; 执行者（Executors）在前面的所有示例中，由Runnable对象定义的新线程和由对象定义的线程本身完成的任务之间存在紧密的联系Thread。这适用于小型应用程序，但在大型应用程序中，将线程管理和创建与应用程序的其余部分分开是有意义的。封装这些函数的对象称为执行程序（Executors）。以下小节详细描述了执行程序。 Executor Interfaces定义三个执行器对象类型。 线程池是最常见的执行器实现类型。 Fork / Join是一个利用多个处理器的框架（JDK 7中的新增功能）。 执行器接口该java.util.concurrent包定义了三个执行器接口： Executor，一个支持启动新任务的简单接口。 ExecutorService，Executor的子接口，增加了有助于管理生命周期的功能，包括单个任务和执行程序本身。 ScheduledExecutorService，ExecutorService的子接口，支持未来和/或定期执行任务。 通常，引用executor对象的变量被声明为这三种接口类型之一，而不是执行器类类型。 Executor Executor接口提供了一种方法，execute旨在成为常见的线程创建习惯用语的替代品。如果r是Runnable对象，e则Executor可以替换为对象 1(new Thread(r)).start(); 同 1e.execute(r); 但是，定义execute不太具体。低级习语创建一个新线程并立即启动它。根据Executor实现，execute可能会执行相同的操作，但更有可能使用现有的工作线程来运行r，或者放入r队列以等待工作线程变为可用。（我们将在线程池的部分中描述工作线程。） 执行程序实现java.util.concurrent旨在充分利用更高级ExecutorService和ScheduledExecutorService接口，尽管它们也可以与基本Executor接口一起使用。 ExecutorService 该 ExecutorService接口补充了execute相似的，但更通用的submit方法。就像execute，submit接受Runnable对象，但也接受 Callable允许任务返回值的对象。该submit方法返回一个 Future对象，该对象用于检索Callable返回值并管理两者Callable和Runnable任务的状态。 ExecutorService还提供了提交大量Callable对象的方法。最后，ExecutorService提供了许多用于管理执行程序关闭的方法。为了支持立即关闭，任务应该正确处理中断。 ScheduledExecutorService 该 ScheduledExecutorService接口补充其父接口ExecutorService schedule方法 ，其执行Runnable或Callable在指定延迟后的任务。此外，接口定义scheduleAtFixedRate并scheduleWithFixedDelay以规定的间隔重复执行指定的任务。 线程池大多数执行程序实现都在java.util.concurrent使用线程池，它由工作线程组成。这种线程Runnable与Callable它执行的任务分开存在，通常用于执行多个任务。 使用工作线程可以最大限度地减少由于创建线程而产生 线程对象使用的大量内存，而在大型应用程序中，分配和释放许多线程对象会产生大量的内存管理开销。 一种常见类型的线程池是固定线程池。这种类型的池总是运行指定数量的线程; 如果某个线程在仍在使用时以某种方式终止，它将自动替换为新线程。任务通过内部队列提交到池中，只要有多个活动任务而不是线程，该队列就会保存额外的任务。 固定线程池的一个重要优点是使用它的应用程序可以优雅地降级。要理解这一点，请考虑一个Web服务器应用程序，其中每个HTTP请求都由一个单独的线程处理。如果应用程序只为每个新的HTTP请求创建一个新线程，并且系统接收的请求数超过它可以立即处理的数量，那么当所有这些线程的开销超过系统容量时，应用程序将突然停止响应所有请求。由于可以创建的线程数量有限制，应用程序不会像它们进入时那样快速地为HTTP请求提供服务，但它将在系统可以维持的时间内尽快为它们提供服务。 创建使用固定线程池的执行程序的一种简单方法是调用 newFixedThreadPool工厂方法。 java.util.concurrent.Executors此类还提供以下工厂方法： 该 newCachedThreadPool方法使用可扩展线程池创建执行程序。此执行程序适用于启动许多短期任务的应用程序。 该 newSingleThreadExecutor方法创建一次执行单个任务的执行程序。 几种工厂方法是ScheduledExecutorService版本创建上述执行器。 如果上述工厂方法提供的执行者都不满足您的需求，则构建实例 java.util.concurrent.ThreadPoolExecutor或 java.util.concurrent.ScheduledThreadPoolExecutor将为您提供其他选项。 fork / join fork / join框架是ExecutorService接口的实现，可帮助您利用多个处理器。它专为可以递归分解成小块的工作而设计。目标是使用所有可用的处理能力来增强应用程序的性能。 与任何ExecutorService实现一样，fork / join框架将任务分配给线程池中的工作线程。fork / join框架是不同的，因为它使用了工作窃取（work-stealing ）算法。不用做的事情的工作线程可以从仍然忙碌的其他线程中窃取任务。（可以想象递归的操作） fork / join框架的中心是ForkJoinPool类，是 扩展AbstractExecutorService。ForkJoinPool实现核心工作窃取算法并可以执行 ForkJoinTask进程。 基本用法 使用fork / join框架的第一步是编写执行一部分工作的代码。您的代码应类似于以下伪代码： 12345如果（我的工作部分足够小） 直接做这项工作否则 把我的工作分成两部分 调用这两个部分并等待结果 将此代码包装在ForkJoinTask子类中，通常使用其中一种更专业的类型 RecursiveTask（可以返回结果）或 RecursiveAction。 在您的ForkJoinTask子类是准备好了，创建一个表示要完成所有的工作对象，把它传递给一个ForkJoinPool实例的invoke()方法。 模糊为Clarity 为了帮助您了解fork / join框架的工作原理，请考虑以下示例。假设您想模糊图像。原始源图像由整数数组表示，其中每个整数包含单个像素的颜色值。模糊的目标图像也由与源相同大小的整数数组表示。 通过一次一个像素地处理源阵列来完成模糊。每个像素与其周围像素平均（红色，绿色和蓝色分量被平均），结果放在目标数组中。由于图像是大型数组，因此此过程可能需要很长时间。通过使用fork / join框架实现算法，您可以利用多处理器系统上的并发处理。这是一个可能的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ForkBlur extends RecursiveAction &#123; private int[] mSource; private int mStart; private int mLength; private int[] mDestination; // Processing window size; should be odd. private int mBlurWidth = 15; public ForkBlur(int[] src, int start, int length, int[] dst) &#123; mSource = src; mStart = start; mLength = length; mDestination = dst; &#125; protected void computeDirectly() &#123; int sidePixels = (mBlurWidth - 1) / 2; for (int index = mStart; index &lt; mStart + mLength; index++) &#123; // Calculate average. float rt = 0, gt = 0, bt = 0; for (int mi = -sidePixels; mi &lt;= sidePixels; mi++) &#123; int mindex = Math.min(Math.max(mi + index, 0), mSource.length - 1); int pixel = mSource[mindex]; rt += (float)((pixel &amp; 0x00ff0000) &gt;&gt; 16) / mBlurWidth; gt += (float)((pixel &amp; 0x0000ff00) &gt;&gt; 8) / mBlurWidth; bt += (float)((pixel &amp; 0x000000ff) &gt;&gt; 0) / mBlurWidth; &#125; // Reassemble destination pixel. int dpixel = (0xff000000 ) | (((int)rt) &lt;&lt; 16) | (((int)gt) &lt;&lt; 8) | (((int)bt) &lt;&lt; 0); mDestination[index] = dpixel; &#125; &#125; ... 现在实现抽象compute()方法，该方法直接执行模糊或将其拆分为两个较小的任务。简单的数组长度阈值有助于确定是执行还是拆分工作。 1234567891011121314protected static int sThreshold = 100000;protected void compute() &#123; if (mLength &lt; sThreshold) &#123; computeDirectly(); return; &#125; int split = mLength / 2; invokeAll(new ForkBlur(mSource, mStart, split, mDestination), new ForkBlur(mSource, mStart + split, mLength - split, mDestination));&#125; 如果以前的方法在类的子RecursiveAction类中，那么将任务设置为在a中运行ForkJoinPool很简单，并涉及以下步骤： 创建一个代表要完成的所有工作的任务。 123//源图像像素在src中//目标图像像素在dst中ForkBlur fb = new ForkBlur(src, 0, src.length, dst); 创建ForkJoinPool将运行任务的那个。 1ForkJoinPool pool = new ForkJoinPool(); 运行任务。 1pool.invoke(fb); 有关完整源代码，包括一些创建目标映像文件的额外代码，请参阅 ForkBlur示例。 标准实现 除了使用fork / join框架来实现在多处理器系统上同时执行的任务的自定义算法（例如ForkBlur.java上一节中的示例）之外，Java SE中有一些通常有用的功能，它们已经使用fork / join实现了框架。在Java SE 8中引入的一种这样的实现被 java.util.Arrays类用于其parallelSort()方法。这些方法类似于sort()，但通过fork / join框架利用并发性。在多处理器系统上运行时，大型阵列的并行排序比顺序排序更快。但是，这些方法如何利用fork / join框架超出了Java Tutorials的范围。有关此信息，请参阅Java API文档。 fork / join框架的另一个实现由java.util.streams包中的方法使用，该方法是为Java SE 8发布而安排的Project Lambda的一部分。 并发集合该java.util.concurrent软件包包括Java Collections Framework的许多新增功能。这些最容易通过提供的集合接口进行分类： BlockingQueue 定义先进先出数据结构，当您尝试添加到完整队列或从空队列中检索时，该数据结构会阻塞或超时。 ConcurrentMap是java.util.Map定义有用原子操作的子接口 。仅当密钥存在时，这些操作才会删除或替换键值对，或仅在密钥不存在时才添加键值对。使这些操作原子化有助于避免同步。标准的通用实现ConcurrentMap是 ConcurrentHashMap，它是一个并发的模拟 HashMap。 ConcurrentNavigableMap是ConcurrentMap支持近似匹配的子接口。标准的通用实现ConcurrentNavigableMap是 ConcurrentSkipListMap，它是一个并发的模拟 TreeMap。 所有这些集合通过定义将对象添加到集合的操作与访问或删除该对象的后续操作之间的先发生关系来帮助避免内存一致性错误。 原子变量该 java.util.concurrent.atomic包定义了支持单个变量的原子操作的类。所有类都有get和set类似读取和写入volatile变量的方法。也就是说，a set与get同一变量上的任何后续关系具有先发生关系。原子compareAndSet方法也具有这些内存一致性功能，适用于整数原子变量的简单原子算法也是如此。 要查看如何使用此包，让我们返回到 Counter我们最初用于演示线程干扰的类： 12345678910111213141516class Counter &#123; private int c = 0; public void increment() &#123; c++; &#125; public void decrement() &#123; c--; &#125; public int value() &#123; return c; &#125;&#125; 使一种方式Counter安全从线程干扰使其同步的方法，如 SynchronizedCounter： 12345678910111213141516class SynchronizedCounter &#123; private int c = 0; public synchronized void increment() &#123; c++; &#125; public synchronized void decrement() &#123; c--; &#125; public synchronized int value() &#123; return c; &#125;&#125; 对于这个简单的类，同步是可接受的解决方案。但是对于更复杂的类，我们可能希望避免不必要的同步对活动的影响。使用a替换int字段AtomicInteger允许我们在不诉诸同步的情况下防止线程干扰，如 AtomicCounter： 123456789101112131415161718import java.util.concurrent.atomic.AtomicInteger;class AtomicCounter &#123; private AtomicInteger c = new AtomicInteger(0); public void increment() &#123; c.incrementAndGet(); &#125; public void decrement() &#123; c.decrementAndGet(); &#125; public int value() &#123; return c.get(); &#125;&#125; 并发随机数在JDK 7中， java.util.concurrent包括一个便利类， ThreadLocalRandom用于期望使用来自多个线程或ForkJoinTasks的随机数的应用程序。 对于并发访问，使用ThreadLocalRandom而不是Math.random()在较少的争用中获得结果，并最终获得更好的性能。 您需要做的就是调用ThreadLocalRandom.current()，然后调用其中一个方法来检索随机数。这是一个例子： 1int r = ThreadLocalRandom.current() .nextInt(4, 77); 进一步阅读 Java Concurrent Animated：显示并发功能用法的动画。 codegit]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式简介]]></title>
    <url>%2F2019%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[背景 随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 单一应用架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。 垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。 转载自 http://dubbo.apache.org/zh-cn/docs/user/preface/background.html]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元日]]></title>
    <url>%2F2019%2F%E5%85%83%E6%97%A5%2F</url>
    <content type="text"><![CDATA[宋：王安石爆竹声中一岁除，春风送暖入屠苏。千门万户曈曈日，总把新桃换旧符。]]></content>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary]]></title>
    <url>%2F2018%2Fdiary%2F</url>
    <content type="text"><![CDATA[杭州又下雪了，2018年的最后一场雪~ ヾ(･ω･`｡)]]></content>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线资源]]></title>
    <url>%2F2018%2Fonline-resource%2F</url>
    <content type="text"><![CDATA[VisuAlgo(数据结构和算法动态可视化) jsr beanvalidation]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>在线资源</tag>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线书籍（文档）推荐]]></title>
    <url>%2F2018%2F%E5%9C%A8%E7%BA%BF%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[官方git（中文） Chrome扩展及应用开发 Google Java Style]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>书籍推荐</tag>
        <tag>文档推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式手册]]></title>
    <url>%2F2018%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[div.main_div { font-family: sans-serif; font-size: 1em; } table.wikitable { background: none repeat scroll 0 0 #F9F9F9; border: 1px solid #AAAAAA; border-collapse: collapse; color: black; } .wikitable th, .wikitable td { border: 1px solid #AAAAAA; padding: 0.2em; } .wikitable th { background: none repeat scroll 0 0 #F2F2F2; text-align: center; } p { line-height: 1.5em; margin: 0.4em 0 0.5em; } h2{ margin:0; font-weight:normal;} 表达式 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\\”匹配“\”而“\(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.|\n)”的模式。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。 x|y 匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \B 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \cx 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \d 匹配一个数字字符。等价于[0-9]。 \D 匹配一个非数字字符。等价于[^0-9]。 \f 匹配一个换页符。等价于\x0c和\cL。 \n 匹配一个换行符。等价于\x0a和\cJ。 \r 匹配一个回车符。等价于\x0d和\cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于[^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于\x09和\cI。 \v 匹配一个垂直制表符。等价于\x0b和\cK。 \w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。. \num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。 \nml 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（&copy;）。 常用正则表达式 用户名 /^[a-z0-9_-]{3,16}$/ 密码 /^[a-z0-9_-]{6,18}$/ 十六进制值 /^#?([a-f0-9]{6}|[a-f0-9]{3})$/ 电子邮箱 /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/ /^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$/ URL /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/ IP 地址 /((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)//^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/ HTML 标签 /^&lt;([a-z]+)([^&lt;]+)*(?:&gt;(.*)&lt;\/\1&gt;|\s+\/&gt;)$/ 删除代码\\注释 (?&lt;!http:|\S)//.*$ Unicode编码中的汉字范围 /^[\u2E80-\u9FFF]+$/]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源许可协议]]></title>
    <url>%2F2018%2F%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[GNU GPL（GNU General Public License，GNU通用公共许可证）：只要软件中包含了遵循GPL协议的产品或代码，该软件就必须也遵循GPL许可协议且开源、免费，因此这个协议并不适合商用软件。遵循该协议的开源软件数量极其庞大，包括Linux系统在内的大多数的开源软件都是基于这个协议的。GPL开源许可协议最大的4个特点如下所示。 复制自由：允许把软件复制到任何人的电脑中，并且不限制复制的数量。 传播自由：允许软件以各种形式进行传播。 收费传播：允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的；因此，一般来讲，开源软件都是通过为用户提供有偿服务的形式来盈利的。 修改自由：允许开发人员增加或删除软件的功能，但软件修改后必须依然基于GPL许可协议授权。 BSD（Berkeley Software Distribution，伯克利软件发布版）许可协议： 用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面3个条件。 如果再发布的软件中包含源代码，则源代码必须继续遵循BSD许可协议。 如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了BSD协议。 不允许用原始软件的名字、作者名字或机构名称进行市场推广。 Apache许可证版本（Apache License Version）许可协议： 在为开发人员提供版权及专利许可的同时，允许用户拥有修改代码及再发布的自由。该许可协议适用于商业软件，现在热门的Hadoop、Apache HTTP Server、MongoDB等项目都是基于该许可协议研发的，程序开发人员在开发遵循该协议的软件时，要严格遵守下面的4个条件。 该软件及其衍生品必须继续使用Apache许可协议。 如果修改了程序源代码，需要在文档中进行声明。 若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息。 如果再发布的软件中有声明文件，则需在此文件中标注Apache许可协议及其他许可协议。 MPL（Mozilla Public License，Mozilla公共许可）许可协议：相较于GPL许可协议，MPL更加注重对开发者的源代码需求和收益之间的平衡。 MIT（Massachusetts Institute of Technology）许可协议：目前限制最少的开源许可协议之一，只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，因此普遍被商业软件所使用。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>开源许可协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git改变已经提交作者信息]]></title>
    <url>%2F2018%2Fgit%E6%94%B9%E5%8F%98%E5%B7%B2%E7%BB%8F%E6%8F%90%E4%BA%A4%E4%BD%9C%E8%80%85%2F</url>
    <content type="text"><![CDATA[打开终端（Mac 或 Linux 用户）或命令行（Windows 用户）。 创建一个你的 repo 的全新裸 clone （repo.git 替换为你的项目，下同） 12git clone --bare https://github.com/user/repo.gitcd repo.git 复制粘贴脚本，并根据你的信息修改以下变量： OLD_EMAIL CORRECT_NAME CORRECT_EMAIL 脚本： 12345678910111213141516171819#!/bin/shgit filter-branch --env-filter 'OLD_EMAIL="your-old-email@example.com"CORRECT_NAME="Your Correct Name"CORRECT_EMAIL="your-correct-email@example.com"if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]then export GIT_COMMITTER_NAME="$CORRECT_NAME" export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"fiif [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]then export GIT_AUTHOR_NAME="$CORRECT_NAME" export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"fi ' --tag-name-filter cat -- --branches --tags 按 Enter 执行脚本。 查看新 Git 历史有没有错误。 把正确历史 push 到 Github：（push 有困难时记得修改 DNS 或者搭梯子） 1git push --force --tags origin 'refs/heads/*' 清除临时 clone。 12cd ..rm -rf repo.git]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[劝学]]></title>
    <url>%2F2018%2F%E5%8A%9D%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[荀子 君子曰：学不可以已。青，取之于蓝，而青于蓝；冰，水为之，而寒于水。木直中绳，輮以为轮，其曲中规，虽有槁暴，不复挺者，輮使之然也。故木受绳则直，金就砺则利，君子博学而日参省乎己，则知明而行无过矣。吾尝终日而思矣，不如须臾之所学也。吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。 积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。]]></content>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片分享]]></title>
    <url>%2F2018%2F%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[师说]]></title>
    <url>%2F2018%2F2018-10-10-%E5%B8%88%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[唐-韩愈 古之学者必有师。师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师,其为惑也终不解矣。生乎吾前，其闻道也固先乎吾，吾从而师之；生乎吾后，其闻道也亦先乎吾，吾从而师之。吾师道也，夫庸知其年之先后生于吾乎？是故无贵无贱，无长无少，道之所存，师之所存也。嗟乎！师道之不传也久矣！欲人之无惑也难矣！古之圣人，其出人也远矣，犹且从师而问焉；今之众人，其下圣人也亦远矣，而耻学于师。是故圣益圣，愚益愚。圣人之所以为圣，愚人之所以为愚，其皆出于此乎?爱其子，择师而教之；于其身也，则耻师焉，惑矣。彼童子之师，授之书而习其句读者，非吾所谓传其道解其惑者也。句读之不知，惑之不解，或师焉，或不焉，小学而大遗，吾未见其明也。巫医乐师百工之人，不耻相师。士大夫之族，曰师曰弟子云者，则群聚而笑之。问之，则曰：“彼与彼年相若也，道相似也，位卑则足羞，官盛则近谀。”呜呼！师道之不复,可知矣。巫医乐师百工之人，君子不齿，今其智乃反不能及，其可怪也欤！ 圣人无常师。孔子师郯子、苌弘、师襄、老聃。郯子之徒，其贤不及孔子。孔子曰：“三人行，则必有我师”。是故弟子不必不如师，师不必贤于弟子。闻道有先后，术业有专攻，如是而已。 李氏子蟠，年十七，好古文，六艺经传皆通习之，不拘于时，学于余。余嘉其能行古道，作《师说》以贻之。]]></content>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OO 思想]]></title>
    <url>%2F2018%2F2018-10-10-OO-mind%2F</url>
    <content type="text"><![CDATA[原创整理与编写，转载请注明出处 三大特性封装软件对象包括状态和相关行为。 方法对的内部状态进行操作，并作为对象通信的主要机制。 隐藏内部状态并要求通过对象的方法执行所有交互称为数据封装 - 面向对象编程的基本原则。 好处： 模块化：可以独立于其他对象的源码。 信息隐藏：内部实现的细节隐藏于外部。 代码重用：如果对象已存在，则可以重用。 可插拔性和调试简易性：如果某个对象有问题，只需将其从应用程序中删除，然后插入另一个对象作为替代。这类似于现实世界中的机械问题：如果螺栓断裂，更换它就行，不用换整个机器。 继承 在Java语言中，类可以从其他类派生，从而继承字段和方法。 子类从其超类继承（这里的继承要理解为拷贝）所有成员（字段，方法和嵌套类）。构造函数不是成员，它们不会类继承，但可以从子类调用。 继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。 可以在子类中执行的操作 子类继承所有公共成员和受保护成员。如果子类与父类在同一个包中，它还继承父类包私有成员。 下面是一些注意点： 子类中声明同名字段，会隐藏父类字段（不推荐）。 子类中编写一个新的静态方法，与父类具有相同的签名，会实现隐藏。 子类中编写一个新实例方法，与父类具有相同的签名，会实现覆盖。 子类构造函数，它可以隐式地或使用关键字来调用父类的构造函数。 父类私有域 子类不继承父类的private成员。 嵌套类可以访问其封闭类的所有私有成员 - 包括字段和方法。于是，子类继承的嵌套类可以间接访问超类的所有私有成员。 @see code 多态 Java虚拟机（JVM）为每个变量引用的对象调用适当的方法。它不会调用声明类型的方法。此行为称为虚方法调用。 多态的三个条件： 继承 覆盖（重写） 向上转型 @see code 抽象的一些tip抽象类与接口 抽象类与接口类似，都无法实例化。但是，使用抽象类，可以声明非静态和非final的字段，并定义public，protected和private方法。使用接口，所有字段都自动为public，static和final，所有方法（作为默认方法）都是公共的。此外，只能扩展一个类，而可以实现多个接口。 使用哪个？ 抽象类： 公用的方法或字段，或者需要除public之外的访问修饰符（例如protected和private）。 声明非静态或非最终字段 接口： 不相关的类会实现，代表特性。如，接口 Comparable以及 Cloneable 指定特定数据类型的行为，但不关心谁实现。 多重继承。 JDK中的抽象类的示例 AbstractMap是集合框架的一部分。它的子类（包括HashMap，TreeMap，和ConcurrentHashMap）共享许多方法（包括get，put，isEmpty，containsKey，和containsValue）。 HashMap实现了接口Serializable，Cloneable和Map&lt;K, V&gt;。通过阅读接口列表，可以推断出HashMap（可以克隆的）实例是可序列化的（这意味着它可以转换为字节流 ），并具有Map的功能。 对象关系这里简单讲下uml里的对象关系，复杂设计可能会用到这些概念。 泛化关系 (Generalization)用来描述继承关系，在 Java 中使用 extends 关键字。 实现关系 (Realization)用来实现一个接口，在 Java 中使用 implement 关键字。 聚合关系 (Aggregation)表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。 组合关系 (Composition)和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。 关联关系 (Association)表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。 依赖关系 (Dependency)和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式： A 类是 B 类方法的局部变量； A 类是 B 类方法当中的一个参数； A 类向 B 类发送消息，从而影响 B 类发生变化。 设计理念Steve Smith在微软TechED 上有个SOLIDify Your ASP.NET MVC的讲座, 很好的解释了SOLID原则。 SOLID（稳固的） 简写 全拼 中文翻译 SRP The Single Responsibility Principle 单一责任原则 OCP The Open Closed Principle 开放封闭原则 LSP The Liskov Substitution Principle 里氏替换原则 ISP The Interface Segregation Principle 接口分离原则 DIP The Dependency Inversion Principle 依赖倒置原则 1. 单一责任原则 修改一个类的原因应该只有一个。 换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。 如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。 @see java.util.Map，java.util.Collection 2. 开放封闭原则 类应该对扩展开放，对修改关闭。 在穿外套时不需要开胸手术。 扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。 符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。 @see java.lang.Iterable 3. 里氏替换原则 子类对象必须能够替换掉所有父类对象。 如果它看起来像一只鸭子，像鸭子一样嘎嘎叫，但需要电池——你可能有了错误的抽象。 继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。 如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。 @see java.util.ArrayList，和其他java集合类 4. 接口分离原则 不应该强迫客户依赖于它们不用的方法。使用多个专门的接口比使用单一的总接口总要好。 你要我插到哪个接口？ 因此使用多个专门的接口比使用单一的总接口要好。 @see java.util.Map，java.util.Collection 5. 依赖倒置原则 底层模块不应该依赖于上层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。 你会把一盏灯直接焊接到墙上的电线上吗？ 底层模块包含一个应用程序中重要的策略选择和业务模块；如果底层模块依赖于上层模块，那么上层模块的改动就会直接影响到底层模块，从而迫使底层模块也需要改动。 @see java.util.Map，java.util.Collection 其他常见原则除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。 简写 全拼 中文翻译 LOD The Law of Demeter 迪米特法则 CRP The Composite Reuse Principle 合成复用原则 CCP The Common Closure Principle 共同封闭原则 SAP The Stable Abstractions Principle 稳定抽象原则 SDP The Stable Dependencies Principle 稳定依赖原则 1. 迪米特法则迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解。 尽量调用他们的公开方法。 2. 合成复用原则尽量使用对象组合，而不是通过继承来达到复用的目的。这样可以解耦。 3. 共同封闭原则一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。 所以按业务区分包也是不错的选择，可以较充分包可见性。 4. 稳定抽象原则最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。 @see javax.validation.validation-api 5. 稳定依赖原则包之间的依赖关系都应该是稳定向依赖，包要依赖的包要比自己更具有稳定性。 所以尽量依赖jdk，再就是一些广泛使用的第三方框架，后续是小众框架。 软件设计通用原则 不做重复的事（DRY，Don’t Repeat Yourself） 在一定范围内抽象功能，不要重复。 降低可管理单元复杂度的一个基本策略就是将他们拆解成更小的单元。 违反DRY原则的解决方案通常被称为WET，指代“write everything twice”。 spring文档里面经常提到这个原则。 有需要可以尝试第三方工具如 apache common utils、guava等。 保持简单直接（KISS，Keep it Simple Stupid） 坚持简约原则，避免不必要的复杂化。 对外的接口尽量简洁明了。 这样上游和用户可以减少疑问，也降低沟通成本。 把一个事情搞复杂是一件简单的事，但要把一个复杂的事变简单，这是一件复杂的事。 你不需要它(YAGNI，You Ain’t Gonna Need It) 这是”极限编程”提倡的原则，指的是你自以为有用的功能，实际上都是用不到的。因此，除了最核心（需要）的功能，其他功能一概不要部署，这样可以大大加快开发。 它背后的指导思想，就是尽可能快、尽可能简单地让软件运行起来（do the simplest thing that could possibly work） 就是避免过度设计。 使用2次以上可以考虑抽取功能。 批判性思考[美] Kirk Knoernschild 在“java应用架构设计：模块化模式与OSGi”提到一个悖论： 重用/可用悖论（重用悖论） 最大化重用会使得可用复杂化。 总体而言，软件模块的可重用性越高，这个模块使用起来就越困难。 所以，软件设计要在重用和可用中找到一个折衷点。 spring项目其实做了很好的折衷： 它分成了几个块： 核心技术：依赖注入，事件，资源，i18n，验证，数据绑定，类型转换，SpEL，AOP。 测试：模拟对象，TestContext框架，Spring MVC测试，WebTestClient。 数据访问：事务，DAO支持，JDBC，ORM，编组XML。 Spring MVC和 Spring WebFlux Web框架。 集成：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。 语言：Kotlin，Groovy，动态语言。 我们可以按需依赖其中几个而不必依赖所有的。spring没有划分的非常细，它划了几个通用的包，使得使用者易于使用，也达到了不错的重用效果。 后记主要是记住OO3大特性和OO5大原则，在遵守原则的同时可以尽量运用特性进行编程简化。 重用可用悖论也是我们要思考的问题，他说明了了软件设计中模块（代码）粒度需要折衷。 而运用这些原则和特性的目的是实现可读、可维护、可复用、易用的代码，模块，项目和业务系统。 其他原则也可以适时适度的参考。 codecode —–转载请注明出处—–]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>oom</tag>
      </tags>
  </entry>
</search>
