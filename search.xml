<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[开源许可协议]]></title>
    <url>%2F2018%2F10%2F15%2F%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[GNU GPL（GNU General Public License，GNU通用公共许可证）：只要软件中包含了遵循GPL协议的产品或代码，该软件就必须也遵循GPL许可协议且开源、免费，因此这个协议并不适合商用软件。遵循该协议的开源软件数量极其庞大，包括Linux系统在内的大多数的开源软件都是基于这个协议的。GPL开源许可协议最大的4个特点如下所示。 复制自由：允许把软件复制到任何人的电脑中，并且不限制复制的数量。 传播自由：允许软件以各种形式进行传播。 收费传播：允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的；因此，一般来讲，开源软件都是通过为用户提供有偿服务的形式来盈利的。 修改自由：允许开发人员增加或删除软件的功能，但软件修改后必须依然基于GPL许可协议授权。 BSD（Berkeley Software Distribution，伯克利软件发布版）许可协议： 用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面3个条件。 如果再发布的软件中包含源代码，则源代码必须继续遵循BSD许可协议。 如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了BSD协议。 不允许用原始软件的名字、作者名字或机构名称进行市场推广。 Apache许可证版本（Apache License Version）许可协议： 在为开发人员提供版权及专利许可的同时，允许用户拥有修改代码及再发布的自由。该许可协议适用于商业软件，现在热门的Hadoop、Apache HTTP Server、MongoDB等项目都是基于该许可协议研发的，程序开发人员在开发遵循该协议的软件时，要严格遵守下面的4个条件。 该软件及其衍生品必须继续使用Apache许可协议。 如果修改了程序源代码，需要在文档中进行声明。 若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息。 如果再发布的软件中有声明文件，则需在此文件中标注Apache许可协议及其他许可协议。 MPL（Mozilla Public License，Mozilla公共许可）许可协议：相较于GPL许可协议，MPL更加注重对开发者的源代码需求和收益之间的平衡。 MIT（Massachusetts Institute of Technology）许可协议：目前限制最少的开源许可协议之一，只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，因此普遍被商业软件所使用。]]></content>
      <tags>
        <tag>开源许可协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git改变已经提交作者信息]]></title>
    <url>%2F2018%2F10%2F15%2Fgit%E6%94%B9%E5%8F%98%E5%B7%B2%E7%BB%8F%E6%8F%90%E4%BA%A4%E4%BD%9C%E8%80%85%2F</url>
    <content type="text"><![CDATA[打开终端（Mac 或 Linux 用户）或命令行（Windows 用户）。 创建一个你的 repo 的全新裸 clone （repo.git 替换为你的项目，下同） 12git clone --bare https://github.com/user/repo.gitcd repo.git 复制粘贴脚本，并根据你的信息修改以下变量： OLD_EMAIL CORRECT_NAME CORRECT_EMAIL 脚本： 12345678910111213141516171819#!/bin/shgit filter-branch --env-filter 'OLD_EMAIL="your-old-email@example.com"CORRECT_NAME="Your Correct Name"CORRECT_EMAIL="your-correct-email@example.com"if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]then export GIT_COMMITTER_NAME="$CORRECT_NAME" export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"fiif [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]then export GIT_AUTHOR_NAME="$CORRECT_NAME" export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"fi ' --tag-name-filter cat -- --branches --tags 按 Enter 执行脚本。 查看新 Git 历史有没有错误。 把正确历史 push 到 Github：（push 有困难时记得修改 DNS 或者搭梯子） 1git push --force --tags origin 'refs/heads/*' 清除临时 clone。 12cd ..rm -rf repo.git]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蝶恋花-春景]]></title>
    <url>%2F2018%2F10%2F10%2F%E8%9D%B6%E6%81%8B%E8%8A%B1-%E6%98%A5%E6%99%AF%2F</url>
    <content type="text"><![CDATA[宋-苏轼 花褪残红青杏小，燕子飞时，绿水人家绕。 枝上柳绵吹又少，天涯何处无芳草！ 墙里秋千墙外道，墙外行人，墙里佳人笑。笑渐不闻声渐悄，多情却被无情恼。]]></content>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一剪梅·舟过吴江]]></title>
    <url>%2F2018%2F10%2F10%2F%E4%B8%80%E5%89%AA%E6%A2%85%C2%B7%E8%88%9F%E8%BF%87%E5%90%B4%E6%B1%9F%2F</url>
    <content type="text"><![CDATA[宋末-蒋捷 一片春愁待酒浇。江上舟摇，楼上帘招。秋娘渡与泰娘桥，风又飘飘，雨又萧萧。 何日归家洗客袍？银字笙调，心字香烧。流光容易把人抛，红了樱桃，绿了芭蕉。]]></content>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[劝学]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%8A%9D%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[荀子 君子曰：学不可以已。青，取之于蓝，而青于蓝；冰，水为之，而寒于水。木直中绳，輮以为轮，其曲中规，虽有槁暴，不复挺者，輮使之然也。故木受绳则直，金就砺则利，君子博学而日参省乎己，则知明而行无过矣。吾尝终日而思矣，不如须臾之所学也。吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。 积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。]]></content>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片分享]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[师说]]></title>
    <url>%2F2018%2F10%2F10%2F2018-10-10-%E5%B8%88%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[唐-韩愈 古之学者必有师。师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师,其为惑也终不解矣。生乎吾前，其闻道也固先乎吾，吾从而师之；生乎吾后，其闻道也亦先乎吾，吾从而师之。吾师道也，夫庸知其年之先后生于吾乎？是故无贵无贱，无长无少，道之所存，师之所存也。嗟乎！师道之不传也久矣！欲人之无惑也难矣！古之圣人，其出人也远矣，犹且从师而问焉；今之众人，其下圣人也亦远矣，而耻学于师。是故圣益圣，愚益愚。圣人之所以为圣，愚人之所以为愚，其皆出于此乎?爱其子，择师而教之；于其身也，则耻师焉，惑矣。彼童子之师，授之书而习其句读者，非吾所谓传其道解其惑者也。句读之不知，惑之不解，或师焉，或不焉，小学而大遗，吾未见其明也。巫医乐师百工之人，不耻相师。士大夫之族，曰师曰弟子云者，则群聚而笑之。问之，则曰：“彼与彼年相若也，道相似也，位卑则足羞，官盛则近谀。”呜呼！师道之不复,可知矣。巫医乐师百工之人，君子不齿，今其智乃反不能及，其可怪也欤！ 圣人无常师。孔子师郯子、苌弘、师襄、老聃。郯子之徒，其贤不及孔子。孔子曰：“三人行，则必有我师”。是故弟子不必不如师，师不必贤于弟子。闻道有先后，术业有专攻，如是而已。 李氏子蟠，年十七，好古文，六艺经传皆通习之，不拘于时，学于余。余嘉其能行古道，作《师说》以贻之。]]></content>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OO 思想]]></title>
    <url>%2F2018%2F10%2F10%2F2018-10-10-OO-mind%2F</url>
    <content type="text"><![CDATA[原创整理与编写，转载请注明出处 三大特性封装软件对象包括==状态和相关行为==。 方法对的内部状态进行操作，并作为==对象通信==的主要机制。 隐藏内部状态并要求通过对象的方法执行所有交互称为==数据封装== - 面向对象编程的基本原则。 好处： 模块化：可以==独立==于其他对象的源码。 信息隐藏：内部实现的细节隐藏于外部。 代码重用：如果对象已存在，则可以重用。 可插拔性和调试简易性：如果某个对象有问题，只需将其从应用程序中删除，然后插入另一个对象作为替代。这类似于现实世界中的机械问题：如果螺栓断裂，更换它就行，不用换整个机器。 继承 在Java语言中，类可以从其他类派生，从而继承字段和方法。 子类从其超类继承（==这里的继承要理解为拷贝==）所有成员（字段，方法和嵌套类）。构造函数不是成员，它们不会类继承，但可以从子类调用。 继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。 可以在子类中执行的操作 子类继承所有==公共成员和受保护成员==。如果子类与父类在同一个包中，它还继承父类包私有成员。 下面是一些注意点： 子类中声明同名字段，会隐藏父类字段（不推荐）。 子类中编写一个新的静态方法，与父类具有相同的签名，会实现隐藏。 子类中编写一个新实例方法，与父类具有相同的签名，会实现覆盖。 子类构造函数，它可以==隐式地或使用关键字==来调用父类的构造函数。 父类私有域 ==子类不继承父类的private成员==。 嵌套类可以访问其封闭类的所有私有成员 - 包括字段和方法。于是，子类继承的嵌套类可以间接访问超类的所有私有成员。 @see code 多态 Java虚拟机（JVM）为每个变量引用的对象调用适当的方法。它不会调用声明类型的方法。此行为称为==虚方法==调用。 多态的三个条件： 继承 覆盖（重写） 向上转型 @see code 抽象的一些tip 抽象类与接口 抽象类与接口类似，都无法实例化。但是，使用抽象类，可以声明非静态和非final的字段，并定义public，protected和private方法。使用接口，==所有字段都自动为public，static和final==，==所有方法（作为默认方法）都是公共的==。此外，只能扩展一个类，而可以实现多个接口。 使用哪个？ 抽象类： 公用的方法或字段，或者需要除public之外的访问修饰符（例如protected和private）。 声明非静态或非最终字段 接口： 不相关的类会实现，代表特性。如，接口 Comparable以及 Cloneable 指定特定数据类型的行为，但不关心谁实现。 多重继承。 JDK中的抽象类的示例 AbstractMap是集合框架的一部分。它的子类（包括HashMap，TreeMap，和ConcurrentHashMap）共享许多方法（包括get，put，isEmpty，containsKey，和containsValue）。 HashMap实现了接口Serializable，Cloneable和Map&lt;K, V&gt;。通过阅读接口列表，可以推断出HashMap（可以克隆的）实例是可序列化的（这意味着它可以转换为字节流 ），并具有Map的功能。 对象关系这里简单讲下uml里的对象关系，复杂设计可能会用到这些概念。 泛化关系 (Generalization)用来描述继承关系，在 Java 中使用 extends 关键字。 实现关系 (Realization)用来实现一个接口，在 Java 中使用 implement 关键字。 聚合关系 (Aggregation)表示整体由部分组成，但是整体和部分==不是强依赖的==，整体不存在了部分还是会存在。 组合关系 (Composition)和聚合不同，组合中==整体和部分是强依赖的==，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。 关联关系 (Association)表示不同类对象之间有关联，这是一种==静态关系==，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。 依赖关系 (Dependency)和关联关系不同的是，依赖关系是在==运行过程中==起作用的。A 类和 B 类是依赖关系主要有三种形式： A 类是 B 类方法的==局部变量==； A 类是 B 类方法当中的一个==参数==； A 类向 B 类发送消息，从而影响 ==B 类发生变化==。 设计理念Steve Smith在微软TechED 上有个SOLIDify Your ASP.NET MVC的讲座, 很好的解释了SOLID原则。 SOLID（稳固的） 简写 全拼 中文翻译 SRP The Single Responsibility Principle 单一责任原则 OCP The Open Closed Principle 开放封闭原则 LSP The Liskov Substitution Principle 里氏替换原则 ISP The Interface Segregation Principle 接口分离原则 DIP The Dependency Inversion Principle 依赖倒置原则 1. 单一责任原则 修改一个类的原因应该只有一个。 换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。 如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。 @see java.util.Map，java.util.Collection 2. 开放封闭原则 类应该对扩展开放，对修改关闭。 在穿外套时不需要开胸手术。 扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。 符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。 @see java.lang.Iterable 3. 里氏替换原则 子类对象必须能够替换掉所有父类对象。 如果它看起来像一只鸭子，像鸭子一样嘎嘎叫，但需要电池——你可能有了错误的抽象。 继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。 如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。 @see java.util.ArrayList，和其他java集合类 4. 接口分离原则 不应该强迫客户依赖于它们不用的方法。使用多个专门的接口比使用单一的总接口总要好。 你要我插到哪个接口？ 因此使用多个专门的接口比使用单一的总接口要好。 @see java.util.Map，java.util.Collection 5. 依赖倒置原则 底层模块不应该依赖于上层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。 你会把一盏灯直接焊接到墙上的电线上吗？ 底层模块包含一个应用程序中重要的策略选择和业务模块；如果底层模块依赖于上层模块，那么上层模块的改动就会直接影响到底层模块，从而迫使底层模块也需要改动。 @see java.util.Map，java.util.Collection 其他常见原则除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。 简写 全拼 中文翻译 LOD The Law of Demeter 迪米特法则 CRP The Composite Reuse Principle 合成复用原则 CCP The Common Closure Principle 共同封闭原则 SAP The Stable Abstractions Principle 稳定抽象原则 SDP The Stable Dependencies Principle 稳定依赖原则 1. 迪米特法则迪米特法则又叫作==最少知识原则==（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解。 尽量调用他们的公开方法。 2. 合成复用原则尽量使用==对象组合==，而不是通过继承来达到复用的目的。这样可以解耦。 3. 共同封闭原则一起修改的类，应该==组合==在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。 所以按业务区分包也是不错的选择，可以较充分包可见性。 4. 稳定抽象原则最稳定的包应该是最==抽象的包==，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。 @see javax.validation.validation-api 5. 稳定依赖原则包之间的依赖关系都应该是==稳定向依赖==，包要依赖的包要比自己更具有稳定性。 所以尽量依赖jdk，再就是一些广泛使用的第三方框架，后续是小众框架。 软件设计通用原则 不做重复的事（DRY，Don’t Repeat Yourself） 在一定范围内==抽象==功能，不要重复。 降低可管理单元复杂度的一个基本策略就是将他们拆解成更小的单元。 违反DRY原则的解决方案通常被称为WET，指代“write everything twice”。 spring文档里面经常提到这个原则。 有需要可以尝试第三方工具如 apache common utils、guava等。 保持简单直接（KISS，Keep it Simple Stupid） 坚持==简约==原则，避免不必要的复杂化。 对外的接口尽量简洁明了。 这样上游和用户可以减少疑问，也降低沟通成本。 把一个事情搞复杂是一件简单的事，但要把一个复杂的事变简单，这是一件复杂的事。 你不需要它(YAGNI，You Ain’t Gonna Need It) 这是”极限编程”提倡的原则，指的是你自以为有用的功能，实际上都是用不到的。因此，除了最==核心==（==需要==）的功能，其他功能一概不要部署，这样可以大大加快开发。 它背后的指导思想，就是尽可能快、尽可能简单地让软件运行起来（do the simplest thing that could possibly work） 就是避免过度设计。 使用2次以上可以考虑抽取功能。 批判性思考[美] Kirk Knoernschild 在“java应用架构设计：模块化模式与OSGi”提到一个悖论： 重用/可用悖论（重用悖论） ==最大化重用会使得可用复杂化。== 总体而言，软件模块的可重用性越高，这个模块使用起来就越困难。 所以，软件设计要在重用和可用中找到一个折衷点。 spring项目其实做了很好的折衷： 它分成了几个块： 核心技术：依赖注入，事件，资源，i18n，验证，数据绑定，类型转换，SpEL，AOP。 测试：模拟对象，TestContext框架，Spring MVC测试，WebTestClient。 数据访问：事务，DAO支持，JDBC，ORM，编组XML。 Spring MVC和 Spring WebFlux Web框架。 集成：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。 语言：Kotlin，Groovy，动态语言。 我们可以按需依赖其中几个而不必依赖所有的。spring没有划分的非常细，它划了几个通用的包，使得使用者易于使用，也达到了不错的重用效果。 后记主要是记住==OO3大特性==和==OO5大原则==，在遵守原则的同时可以尽量运用特性进行编程简化。 ==重用可用悖论==也是我们要思考的问题，他说明了了软件设计中模块（代码）粒度需要折衷。 而运用这些原则和特性的目的是实现==可读、可维护、可复用、易用==的代码，模块，项目和业务系统。 其他原则也可以适时适度的参考。 —–转载请注明出处—–]]></content>
      <tags>
        <tag>java</tag>
        <tag>oom</tag>
      </tags>
  </entry>
</search>
