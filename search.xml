<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[dubbo architecture]]></title>
    <url>%2F2019%2Fdubbo-architecture%2F</url>
    <content type="text"><![CDATA[架构 节点角色说明节点 角色说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 调用关系说明 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。 连通性 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示 服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销 服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者 注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者 健壮性 监控中心宕掉不影响使用，只是丢失部分采样数据 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务 注册中心对等集群，任意一台宕掉后，将自动切换到另一台 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯 服务提供者无状态，任意一台宕掉后，不影响使用 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复 伸缩性 注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心 服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者 升级性当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。下图是未来可能的一种架构： 节点角色说明节点 角色说明 Deployer 自动部署服务的本地代理 Repository 仓库用于存储服务应用发布包 Scheduler 调度中心基于访问压力自动增减服务提供者 Admin 统一管理控制台 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 from: http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo设计需求]]></title>
    <url>%2F2019%2Fdubbo-requirement%2F</url>
    <content type="text"><![CDATA[需求在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。 当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。 此时需要一个服务注册中心，动态地注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清理关系。 接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？ 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。 以上是 Dubbo 最基本的几个需求。 from：http://dubbo.apache.org/zh-cn/docs/user/preface/requirements.html]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InnoDB简介]]></title>
    <url>%2F2019%2FInnoDB%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[15.1 InnoDB简介15.1.1使用InnoDB表的好处 15.1.2 InnoDB表的最佳实践 15.1.3验证InnoDB是默认存储引擎 15.1.4使用InnoDB进行测试和基准测试 InnoDB是一种平衡、高可靠性和高性能的通用存储引擎。在MySQL 8.0中，InnoDB是默认的MySQL存储引擎。除非您配置了不同的默认存​​储引擎，否则发出CREATE TABLE不带ENGINE=子句的语句会创建InnoDB表。 InnoDB的主要优势 它的DML操作遵循ACID模型，具有提交，回滚和崩溃恢复功能的事务来保护用户数据。有关更多信息，请参见第15.2节“InnoDB和ACID模型”。 行级锁定和Oracle风格的一致性读取可提高多用户并发性和性能。有关更多信息，请参见第15.7节“InnoDB锁定和事务模型”。 InnoDB表格将您的数据排列在磁盘上，以根据主键优化查询。每个InnoDB表都有一个称为聚簇索引的主键索引，用于组织数据以最小化主键查找的I / O.有关更多信息，请参见第15.6.2.1节“聚簇和二级索引”。 要保持数据完整性，请InnoDB支持FOREIGN KEY约束。使用外键，将检查插入，更新和删除，以确保它们不会导致不同表之间的不一致。有关更多信息，请参见第15.6.1.5节“InnoDB和FOREIGN KEY约束”。 表15.1 InnoDB存储引擎功能 特征 支持 B树索引 是 备份/时间点恢复（在服务器中实现，而不是在存储引擎中实现。） 是 群集数据库支持 没有 聚集索引 是 压缩数据 是 数据缓存 是 加密数据 是（通过加密功能在服务器中实现;在MySQL 5.7及更高版本中，支持静态数据表空间加密。） 外键支持 是 全文搜索索引 是（在MySQL 5.6及更高版本中可以使用InnoDB对FULLTEXT索引的支持。） 地理空间数据类型支持 是 地理空间索引支持 是（在MySQL 5.7及更高版本中可以使用InnoDB对地理空间索引的支持。） 哈希索引 否（InnoDB在内部利用哈希索引来实现其自适应哈希索引功能。） 索引缓存 是 锁定粒度 行 MVCC 是 复制支持（在服务器中实现，而不是在存储引擎中实现。） 是 存储限制 64TB T树索引 没有 交易 是 更新数据字典的统计信息 是 要比较InnoDBMySQL提供的其他存储引擎的功能，请参阅第16章备用存储引擎中的存储引擎功能表。 InnoDB增强功能和新功能有关InnoDB增强功能和新功能的信息，请参阅： 第1.4节“MySQL 8.0中的新InnoDB功能”中的增强功能列表。 该发行说明。 额外的InnoDB信息和资源 有关InnoDB相关术语和定义，请参阅MySQL词汇表。 对于专用于InnoDB存储引擎的论坛，请参阅MySQL论坛:: InnoDB。 InnoDB以与MySQL相同的GNU GPL许可证版本2（1991年6月）发布。有关MySQL许可的更多信息，请访问http://www.mysql.com/company/legal/licensing/。 原文：https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html]]></content>
      <categories>
        <category>技术</category>
        <category>db</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
        <tag>db</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring mvc请求处理流程]]></title>
    <url>%2F2019%2Fspring-mvc%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Special Bean TypesTheDispatcherServletdelegates to special beans to process requests and render the appropriate responses. By “special beans” we mean Spring-managed, Object instances that implement WebFlux framework contracts. Those usually come with built-in contracts but you can customize their properties, extend or replace them. The table below lists the special beans detected by theDispatcherHandler: Bean type Explanation HandlerMapping Map a request to a handler along with a list ofinterceptorsfor pre- and post-processing. The mapping is based on some criteria the details of which vary byHandlerMappingimplementation.The two mainHandlerMappingimplementations areRequestMappingHandlerMappingwhich supports@RequestMappingannotated methods andSimpleUrlHandlerMappingwhich maintains explicit registrations of URI path patterns to handlers. HandlerAdapter Help theDispatcherServletto invoke a handler mapped to a request regardless of how the handler is actually invoked. For example, invoking an annotated controller requires resolving annotations. The main purpose of aHandlerAdapteris to shield theDispatcherServletfrom such details. HandlerExceptionResolver Strategy to resolve exceptions possibly mapping them to handlers, or to HTML error views, or other. SeeExceptions. ViewResolver Resolve logical String-based view names returned from a handler to an actualViewto render to the response with. SeeView ResolutionandView Technologies. LocaleResolver,LocaleContextResolver Resolve theLocalea client is using and possibly their time zone, in order to be able to offer internationalized views. SeeLocale. ThemeResolver Resolve themes your web application can use, for example, to offer personalized layouts. SeeThemes. MultipartResolver Abstraction for parsing a multi-part request (e.g. browser form file upload) with the help of some multipart parsing library. SeeMultipart resolver. FlashMapManager Store and retrieve the “input” and the “output”FlashMapthat can be used to pass attributes from one request to another, usually across a redirect. SeeFlash attributes. note：这些bean基本处理和串联了整个spring mvc的请求处理流程 内容源自spring文档]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>spring mvc</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka-简介]]></title>
    <url>%2F2019%2FKafka-profile%2F</url>
    <content type="text"><![CDATA[ApacheKafka®是一个分布式流媒体平台。这到底是什么意思呢？流媒体平台有三个关键功能： 发布和订阅记录流，类似于消息队列或企业消息传递系统。 以容错的持久方式存储记录流。 记录发生时处理流。 Kafka通常用于两大类应用： 构建可在系统或应用程序之间可靠获取数据的实时流数据管道 构建转换或响应数据流的实时流应用程序 要了解Kafka如何做这些事情，让我们深入探讨Kafka的能力。 首先是几个概念： Kafka作为一个集群运行在一个或多个可跨多个数据中心的服务器上。 Kafka集群以称为主题的类别存储_记录_流。 每条记录由一个键，一个值和一个时间戳组成。 Kafka有四个核心API： 该制片API允许应用程序发布的记录流至一个或多个卡夫卡的话题。 该消费者API允许应用程序订阅一个或多个主题，并处理所产生的对他们记录的数据流。 所述流API允许应用程序充当流处理器，从一个或多个主题消耗的输入流，并产生一个输出流至一个或多个输出的主题，有效地变换所述输入流，以输出流。 该连接器API允许构建和运行卡夫卡主题连接到现有的应用程序或数据系统中重用生产者或消费者。例如，关系数据库的连接器可能捕获对表的每个更改。 在Kafka中，客户端和服务器之间的通信是通过简单，高性能，语言无关的TCP协议完成的。此协议已版本化并保持与旧版本的向后兼容性。我们为Kafka提供Java客户端，但客户端有多种语言版本。 主题和日志让我们首先深入探讨Kafka为记录流提供的核心抽象 - 主题。 主题是发布记录的类别或订阅源名称。Kafka的主题总是多用户; 也就是说，一个主题可以有零个，一个或多个消费者订阅写入它的数据。 对于每个主题，Kafka群集都维护一个分区日志，如下所示： 每个分区都是一个有序的，不可变的记录序列，不断附加到结构化的提交日志中。分区中的记录每个都被分配一个称为_偏移_的顺序ID号，它唯一地标识分区中的每个记录。 Kafka集群持久地保留所有已发布的记录 - 无论它们是否已被消耗 - 使用可配置的保留期。例如，如果保留策略设置为两天，则在发布记录后的两天内，它可供使用，之后将被丢弃以释放空间。Kafka的性能在数据大小方面实际上是恒定的，因此长时间存储数据不是问题。 事实上，基于每个消费者保留的唯一元数据是该消费者在日志中的偏移或位置。这种偏移由消费者控制：通常消费者在读取记录时会线性地提高其偏移量，但事实上，由于消费者控制位置，它可以按照自己喜欢的任何顺序消费记录。例如，消费者可以重置为较旧的偏移量以重新处理过去的数据，或者跳到最近的记录并从“现在”开始消费。 这些功能组合意味着Kafka消费者非常便宜 - 他们可以来来往往对集群或其他消费者没有太大影响。例如，您可以使用我们的命令行工具“拖尾”任何主题的内容，而无需更改任何现有使用者所消耗的内容。 日志中的分区有多种用途。首先，它们允许日志扩展到超出适合单个服务器的大小。每个单独的分区必须适合托管它的服务器，但主题可能有许多分区，因此它可以处理任意数量的数据。其次，它们充当了并行性的单位 - 更多的是在一点上。 分配日志的分区分布在Kafka集群中的服务器上，每个服务器处理数据并请求分区的共享。每个分区都在可配置数量的服务器上进行复制，以实现容错。 每个分区都有一个服务器充当“领导者”，零个或多个服务器充当“追随者”。领导者处理分区的所有读取和写入请求，而关注者被动地复制领导者。如果领导者失败，其中一个粉丝将自动成为新的领导者。每个服务器都充当其某些分区的领导者和其他服务器的追随者，因此负载在群集中很平衡。 地域复制Kafka MirrorMaker为您的群集提供地理复制支持。使用MirrorMaker，可以跨多个数据中心或云区域复制邮件。您可以在主动/被动方案中使用它进行备份和恢复; 或者在主动/主动方案中，使数据更接近用户，或支持数据位置要求。 生产者生产者将数据发布到他们选择的主题。生产者负责选择分配给主题中哪个分区的记录。这可以通过循环方式完成，只是为了平衡负载，或者可以根据一些语义分区功能（例如基于记录中的某些键）来完成。更多关于在一秒钟内使用分区的信息！ 消费者消费者使用消费者组名称标记自己，并且发布到主题的每个记录被传递到每个订阅消费者组中的一个消费者实例。消费者实例可以在单独的进程中，也可以在不同的机器 如果所有使用者实例具有相同的使用者组，则记录将有效地在使用者实例上进行负载平衡。 如果所有消费者实例具有不同的消费者组，则每个记录将广播到所有消费者进程。 两个服务器Kafka群集，托管四个分区（P0-P3），包含两个使用者组。消费者组A有两个消费者实例，B组有四个消费者实例。 然而，更常见的是，我们发现主题具有少量的消费者群体，每个“逻辑订户”一个。每个组由许多用于可伸缩性和容错的消费者实例组成。这只不过是发布 - 订阅语义，其中订阅者是消费者群集而不是单个进程。 在Kafka中实现消费的方式是通过在消费者实例上划分日志中的分区，以便每个实例在任何时间点都是分配的“公平份额”的独占消费者。维护组中成员资格的过程由Kafka协议动态处理。如果新实例加入该组，他们将从该组的其他成员接管一些分区; 如果实例死亡，其分区将分发给其余实例。 Kafka仅提供分_区内_记录的总订单，而不是主题中不同分区之间的记录。对于大多数应用程序而言，按分区排序与按键分区数据的能力相结合就足够了。但是，如果您需要对记录进行总订单，则可以使用仅包含一个分区的主题来实现，但这将意味着每个使用者组只有一个使用者进程。 多租户您可以将Kafka部署为多租户解决方案。通过配置哪些主题可以生成或使用数据来启用多租户。配额也有运营支持。管理员可以定义和强制执行配额，以控制客户端使用的代理资源。有关更多信息，请参阅安全文档。 担保在高级别Kafka提供以下保证： 生产者发送到特定主题分区的消息将按其发送顺序附加。也就是说，如果记录M1由与记录M2相同的生产者发送，并且首先发送M1，则M1将具有比M2更低的偏移并且在日志中更早出现。 消费者实例按照它们存储在日志中的顺序查看记录。 对于具有复制因子N的主题，我们将容忍最多N-1个服务器故障，而不会丢失任何提交到日志的记录。 有关这些保证的更多详细信息，请参见文档的设计部分。 卡夫卡作为消息系统Kafka的流概念与传统的企业邮件系统相比如何？ 消息传统上有两种模型：排队和发布 - 订阅。在队列中，消费者池可以从服务器读取并且每个记录转到其中一个; 在发布 - 订阅中，记录被_广播给所有消费者。这两种模型中的每一种都有优点和缺点。排队的优势在于它允许您在多个消费者实例上划分数据处理，从而可以扩展您的处理。不幸的是，一旦一个进程读取它已经消失的数据_，队列就不是​​多用户。发布 - 订阅允许您将数据广播到多个进程，但由于每条消息都发送给每个订阅者，因此无法进行扩展处理。 卡夫卡的消费者群体概念概括了这两个概念。与队列一样，使用者组允许您将处理划分为一组进程（使用者组的成员）。与发布 - 订阅一样，Kafka允许您向多个消费者组广播消息。 Kafka模型的优势在于每个主题都具有这些属性 - 它可以扩展处理并且也是多用户 - 不需要选择其中一个。 与传统的消息系统相比，Kafka具有更强的顺序保证。 传统队列在服务器上按顺序保留记录，如果多个消费者从队列中消耗，则服务器按照存储顺序分发记录。但是，虽然服务器按顺序分发记录，但是记录是异步传递给消费者的，因此它们可能会在不同的消费者上无序传送。这实际上意味着在存在并行消耗的情况下丢失记录的顺序。消息传递系统通常通过具有“独占消费者”的概念来解决这个问题，该概念只允许一个进程从队列中消耗，但这当然意味着处理中没有并行性。 卡夫卡做得更好。通过在主题中具有并行性概念 - 分区 - ，Kafka能够在消费者流程池中提供顺序保证和负载平衡。这是通过将主题中的分区分配给使用者组中的使用者来实现的，以便每个分区仅由该组中的一个使用者使用。通过这样做，我们确保使用者是该分区的唯一读者并按顺序使用数据。由于有许多分区，这仍然可以平衡许多消费者实例的负载。但请注意，消费者组中的消费者实例不能超过分区。 Kafka作为存储系统任何允许发布与消费它们分离的消息的消息队列实际上充当了正在进行的消息的存储系统。Kafka的不同之处在于它是一个非常好的存储系统。 写入Kafka的数据将写入磁盘并进行复制以实现容错。Kafka允许生产者等待确认，以便在完全复制之前写入不被认为是完整的，并且即使写入的服务器失败也保证写入仍然存在。 磁盘结构Kafka很好地使用了规模 - 无论服务器上有50 KB还是50 TB的持久数据，Kafka都会执行相同的操作。 由于认真对待存储并允许客户端控制其读取位置，您可以将Kafka视为一种专用于高性能，低延迟提交日志存储，复制和传播的专用分布式文件系统。 有关Kafka的提交日志存储和复制设计的详细信息，请阅读此页面。 Kafka用于流处理仅仅读取，写入和存储数据流是不够的，目的是实现流的实时处理。 在Kafka中，流处理器是指从输入主题获取连续数据流，对此输入执行某些处理以及生成连续数据流以输出主题的任何内容。 例如，零售应用程序可能会接收销售和发货的输入流，并输出重新排序流和根据此数据计算的价格调整。 可以使用生产者和消费者API直接进行简单处理。但是，对于更复杂的转换，Kafka提供了完全集成的Streams API。这允许构建执行非平凡处理的应用程序，这些应用程序可以计算流的聚合或将流连接在一起。 此工具有助于解决此类应用程序面临的难题：处理无序数据，在代码更改时重新处理输入，执行有状态计算等。 流API构建在Kafka提供的核心原语上：它使用生产者和消费者API进行输入，使用Kafka进行有状态存储，并在流处理器实例之间使用相同的组机制来实现容错。 把碎片放在一起消息传递，存储和流处理的这种组合可能看起来很不寻常，但它对于Kafka作为流媒体平台的作用至关重要。 像HDFS这样的分布式文件系统允许存储静态文件以进行批处理。有效地，这样的系统允许存储和处理过去的_历史_数据。 传统的企业邮件系统允许处理订阅后到达的未来邮件。以这种方式构建的应用程序在到达时处理未来数据。 Kafka结合了这两种功能，这种组合对于Kafka作为流媒体应用程序平台以及流数据管道的使用至关重要。 通过组合存储和低延迟订阅，流应用程序可以以相同的方式处理过去和未来的数据。也就是说，单个应用程序可以处理历史存储的数据，而不是在它到达最后一条记录时结束，它可以在未来数据到达时继续处理。这是包含批处理以及消息驱动应用程序的流处理的一般概念。 同样，对于流数据流水线，订阅实时事件的组合使得可以将Kafka用于极低延迟的流水线; 但是，能够可靠地存储数据使得可以将其用于必须保证数据传输的关键数据，或者与仅定期加载数据或可能长时间停机以进行维护的离线系统集成。流处理设施可以在数据到达时对其进行转换。 有关Kafka提供的保证，API和功能的更多信息，请参阅其余文档。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ功能概述]]></title>
    <url>%2F2019%2FOverview-of-ActiveMQ%2F</url>
    <content type="text"><![CDATA[支持Java，C，C ++，C＃，Ruby，Perl，Python，PHP等 各种跨语言客户端和协议 适用于Java，C，C ++，C＃的高性能客户端的OpenWire Stomp支持，以便客户端可以轻松地用C，Ruby，Perl，Python，PHP，ActionScript / Flash，Smalltalk编写，以便与ActiveMQ以及任何其他流行的Message Broker交谈 AMQP v1.0支持 MQTT v3.1支持允许在物联网环境中进行连接。 完全支持JMS客户端和Message Broker中的企业集成模式 支持许多高级功能，如消息组，虚拟目标，通配符和复合目标 完全支持JMS 1.1和J2EE 1.4，支持瞬态，持久，事务和XA消息传递 Spring支持，以便ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置 在流行的J2EE服务器中进行测试，例如TomEE，Geronimo，JBoss，GlassFish和WebLogic 包括用于入站和出站消息传递的JCA 1.5资源适配器，以便ActiveMQ可以在任何符合J2EE 1.4的服务器中自动部署 支持可插拔传输协议，如in-VM，TCP，SSL，NIO，UDP，多播，JGroups和JXTA传输 使用JDBC和高性能日志支持非常快速的持久性 专为高性能群集，客户端 - 服务器，基于对等的通信而设计 REST API，为消息传递提供技术不可知和基于语言的基于Web的API Ajax支持使用纯DHTML对Web浏览器的Web流支持，允许Web浏览器成为消息传递结构的一部分 CXF和Axis支持，以便可以轻松地将ActiveMQ放入这些Web服务堆栈中，以提供可靠的消息传递 可用作内存中的JMS提供程序，非常适合单元测试JMS 原文：https://activemq.apache.org/features-overview]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZooKeeper简介]]></title>
    <url>%2F2019%2FZooKeeper%2F</url>
    <content type="text"><![CDATA[ZooKeeper：分布式应用程序的分布式协调服务ZooKeeper是一种用于分布式应用程序的分布式开源协调服务。它公开了一组简单的原语，分布式应用程序可以构建这些原语，以实现更高级别的服务，以实现同步，配置维护以及组和命名。它被设计为易于编程，并使用在熟悉的文件系统目录树结构之后设计的数据模型。它在Java中运行，并且具有Java和C的绑定。 众所周知，协调服务很难做到。他们特别容易出现比赛条件和死锁等错误。ZooKeeper背后的动机是减轻分布式应用程序从头开始实施协调服务的责任。 设计目标ZooKeeper很简单。ZooKeeper允许分布式进程通过共享的层级命名空间相互协调，该命名空间的组织方式与标准文件系统类似。名称空间由数据寄存器组成 - 在ZooKeeper用语中称为znodes - 这些与文件和目录类似。与专为存储而设计的典型文件系统不同，ZooKeeper数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟数量。 ZooKeeper实现非常重视高性能，高可用性，严格有序的访问。ZooKeeper的性能方面意味着它可以在大型分布式系统中使用。可靠性方面使其不会成为单点故障。严格的排序意味着可以在客户端实现复杂的同步原语。 ZooKeeper被复制。与它协调的分布式进程一样，ZooKeeper本身也可以在称为集合的一组主机上进行复制。 组成ZooKeeper服务的服务器必须彼此了解。它们维护内存中的状态图像，以及持久性存储中的事务日志和快照。只要大多数服务器可用，ZooKeeper服务就可用。 客户端连接到单个ZooKeeper服务器。客户端维护TCP连接，通过该连接发送请求，获取响应，获取监视事件以及发送心跳。如果与服务器的TCP连接中断，则客户端将连接到其他服务器。 ZooKeeper是顺序的。ZooKeeper使用反映所有ZooKeeper事务顺序的数字标记每个更新。后续操作可以使用该顺序来实现更高级别的抽象，例如同步原语。 ZooKeeper很快。它在“读取主导”工作负载中特别快。ZooKeeper应用程序在数千台计算机上运行，​​并且在读取比写入更常见的情况下表现最佳，比率大约为10：1。 数据模型和分层命名空间ZooKeeper提供的名称空间非常类似于标准文件系统。名称是由斜杠（/）分隔的路径元素序列。ZooKeeper名称空间中的每个节点都由路径标识。 ZooKeeper的分层命名空间 节点和短暂节点与标准文件系统不同，ZooKeeper命名空间中的每个节点都可以包含与之关联的数据以及子项。这就像拥有一个允许文件也是目录的文件系统。（ZooKeeper旨在存储协调数据：状态信息，配置，位置信息等，因此存储在每个节点的数据通常很小，在字节到千字节范围内。）我们使用术语znode来说明我们正在谈论ZooKeeper数据节点。 Znodes维护一个stat结构，其中包括数据更改，ACL更改和时间戳的版本号，以允许缓存验证和协调更新。每次znode的数据更改时，版本号都会增加。例如，每当客户端检索数据时，它也接收数据的版本。 存储在命名空间中每个znode的数据以原子方式读取和写入。读取获取与znode关联的所有数据字节，写入替换所有数据。每个节点都有一个访问控制列表（ACL），限制谁可以做什么。 ZooKeeper也有短暂节点的概念。只要创建znode的会话处于活动状态，就会存在这些znode。会话结束时，znode将被删除。当您想要实现[tbd]时，短暂节点很有用。 有条件的更新和监控ZooKeeper支持监控的概念。客户端可以在znode上设置监视。当znode更改时，将触发并删除手表。触发监视时，客户端会收到一个数据包，指出znode已更改。如果客户端与其中一个Zoo Keeper服务器之间的连接中断，则客户端将收到本地通知。这些可以用于[tbd]。 担保ZooKeeper非常快速而且非常简单。但是，由于其目标是构建更复杂的服务（如同步）的基础，因此它提供了一系列保证。这些是： 顺序一致性 - 客户端的更新将按发送顺序应用。 原子性 - 更新成功或失败。没有部分结果。 单系统映像 - 无论服务器连接到哪个服务器，客户端都将看到相同的服务视图。 可靠性 - 一旦应用了更新，它将从那时起持续到客户端覆盖更新。 及时性 - 系统的客户视图保证在特定时间范围内是最新的。 有关这些以及如何使用它们的更多信息，请参阅[tbd] 简单的APIZooKeeper的设计目标之一是提供一个非常简单的编程接口。因此，它仅支持以下操作： create: creates a node at a location in the tree delete: deletes a node exists: tests if a node exists at a location get data: reads the data from a node set data: writes data to a node get children: retrieves a list of children of a node sync: waits for data to be propagated 有关这些内容的更深入讨论，以及如何使用它们来实现更高级别的操作，请参阅[tbd] 履行ZooKeeper Components显示ZooKeeper服务的高级组件。除请求处理器外，构成ZooKeeper服务的每个服务器都复制其自己的每个组件的副本。 复制数据库是包含整个数据树的内存数据库。更新将记录到磁盘以获得可恢复性，并且写入在应用于内存数据库之前会序列化到磁盘。 每个ZooKeeper服务器都为客户端服务。客户端只连接到一台服务器以提交请求。读取请求由每个服务器数据库的本地副本提供服务。更改服务状态，写请求的请求由协议协议处理。 作为协议协议的一部分，来自客户端的所有写入请求都被转发到称为领导者的单个服务器。其余的ZooKeeper服务器（称为关注者）接收来自领导者的消息提议并同意消息传递。消息传递层负责替换失败的领导者并将关注者与领导者同步。 ZooKeeper使用自定义原子消息传递协议。由于消息传递层是原子的，因此ZooKeeper可以保证本地副本永远不会发散。当领导者收到写入请求时，它会计算应用写入时系统的状态，并将其转换为捕获此新状态的事务。 用途ZooKeeper的编程接口非常简单。但是，使用它，您可以实现更高阶的操作，例如同步原语，组成员身份，所有权等。某些分布式应用程序已将其用于：[tbd：从白皮书和视频演示中添加用途。]有关详细信息，请参阅[TBD] 性能ZooKeeper旨在提供高性能。但是吗？ZooKeeper在雅虎开发团队的成果！研究表明它是。（请参阅ZooKeeper吞吐量作为读写比率变化。）在读取数量超过写入的应用程序中，它特别高性能，因为写入涉及同步所有服务器的状态。（读取数量超过写入通常是协调服务的情况。） 该ZooKeeper的吞吐量读写比率发生变化是动物园管理员的吞吐量图3.2版与双2GHz的至强和两个SATA 15K RPM驱动器的服务器上运行。一个驱动器用作专用的ZooKeeper日志设备。快照已写入OS驱动器。写请求是1K写入，读取是1K读取。“服务器”表示ZooKeeper集合的大小，即构成服务的服务器数量。大约30个其他服务器用于模拟客户端。ZooKeeper集合的配置使得领导者不允许来自客户端的连接。 注意 在版本3.2中，与之前的3.1版本相比，r / w性能提高了约2倍。 基准也表明它也是可靠的。存在错误时的可靠性显示了部署如何响应各种故障。图中标记的事件如下： Failure and recovery of a follower Failure and recovery of a different follower Failure of the leader Failure and recovery of two followers Failure of another leader 可靠性为了在注入故障时显示系统随时间的行为，我们运行了由7台机器组成的ZooKeeper服务。我们运行与以前相同的饱和度基准，但这次我们将写入百分比保持在恒定的30％，这是我们预期工作量的保守比率。 这是图表中的一些重要观察结果。首先，如果追随者失败并迅速恢复，那么即使失败，ZooKeeper也能够维持高吞吐量。但也许更重要的是，领导者选举算法允许系统足够快地恢复以防止吞吐量大幅下降。在我们的观察中，ZooKeeper选择新领导者的时间不到200毫秒。第三，随着追随者的恢复，ZooKeeper能够在开始处理请求后再次提高吞吐量。 ZooKeeper项目ZooKeeper已成功用于许多工业应用。它用于Yahoo!作为Yahoo!的协调和故障恢复服务Message Broker，它是一个高度可扩展的发布 - 订阅系统，可管理数千个主题以进行复制和数据传递。雅虎的获取服务使用它！crawler，它还管理故障恢复。一些雅虎！广告系统也使用ZooKeeper来实现可靠的服务。 鼓励所有用户和开发人员加入社区并贡献他们的专业知识。有关更多信息，请参阅Apache上的Zookeeper项目。 原文：https://zookeeper.apache.org/doc/current/zookeeperOver.html]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rocket mq 核心概念]]></title>
    <url>%2F2019%2Frocketmq-Core-Concept%2F</url>
    <content type="text"><![CDATA[核心概念 根据上述模型，我们可以深入探讨有关消息传递系统设计的一些主题： 消费者并发 消费者热点问题 消费者负载平衡 消息路由器 连接多路复用 金丝雀部署（Canary Deployments） 生产者生产者将业务应用程序系统生成的消息发送给代理。RocketMQ提供多种发送范例：同步，异步和单向。 生产者组具有相同角色的生产者组合在一起。如果原始生产者在事务之后崩溃，则代理可以联系同一生产者组的不同生产者实例以提交或回滚事务。 警告：考虑到提供的生产者在发送消息方面足够强大，每个生产者组只允许一个实例，以避免不必要的生成器实例初始化。 消费者消费者从经纪人处获取消息并将其提供给应用程序。从用户应用的角度来看，提供了两种类型的消费者： PullConsumer拉动消费者主动从经纪人那里获取消息。一旦提取了批量消息，用户应用程序就会启动消费过程。 PushConsumer另一方面，推送消费者封装消息提取，消耗进度并维护其他内部工作，留下最终用户的回调接口以实现将在消息到达时执行。 消费者组与之前提到的生产者组类似，完全相同角色的消费者被组合在一起并命名为消费者组。 消费者群体是一个很好的概念，在消息消费方面实现负载平衡和容错目标非常容易。 警告：使用者组的使用者实例必须具有完全相同的主题订阅。 话题主题是生产者传递消息和消费者提取消息的类别。主题与生产者和消费者的关系非常松散。具体而言，主题可能有零个，一个或多个生成器向其发送消息;相反，制作人可以发送不同主题的消息。从消费者的角度来看，主题可以由零个，一个或多个消费者群体订阅。类似地，消费者组可以订阅一个或多个主题，只要该组的实例保持其订阅一致即可。 信息消息是要传递的信息。消息必须有一个主题，可以将其解释为您要发送给的邮件地址。消息还可以具有可选标记和额外的键 - 值对。例如，您可以为消息设置业务密钥，并在代理服务器上查找消息以诊断开发期间的问题。 消息队列主题被划分为一个或多个子主题“消息队列”。 标签标记，换句话说，子主题，为用户提供了额外的灵活性。对于标记，来自同一业务模块的具有不同目的的消息可以具有相同的主题和不同的标记。标签有助于保持代码的清晰和连贯，而标签也可以方便RocketMQ提供的查询系统。 经纪人（Broker）经纪人是RocketMQ系统的主要组成部分。它接收从生产者发送的消息，存储它们并准备处理来自消费者的拉取请求。它还存储与消息相关的元数据，包括消费者组，消耗进度偏移和主题/队列信息。 名称服务器名称服务器充当路由信息提供者。生产者/消费者客户查找主题以查找相应的代理列表。 消息模型 聚类（Clustering） 广播（Broadcasting） 消息顺序使用DefaultMQPushConsumer时，您可能决定按顺序或同时使用消息。 有顺序地 按顺序使用消息意味着消息的消费顺序与生产者为每个消息队列发送的顺序相同。如果您正在处理全局顺序是必需的方案，请确保您使用的主题只有一个消息队列。 警告：如果指定了有序消费，则消息消耗的最大并发数是消费者组订阅的消息队列数。 并发的 在并发使用消息时，消息消耗的最大并发性仅受为每个使用者客户端指定的线程池的限制。 警告：此模式下不再保证消息顺序。 转自：http://rocketmq.apache.org/docs/core-concept/]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>mq</tag>
        <tag>rocket mq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ简介]]></title>
    <url>%2F2019%2FRocketMQ-intro%2F</url>
    <content type="text"><![CDATA[动机在早期阶段，我们构建了基于ActiveMQ 5.x的分布式消息中间件（5.3之前）。我们的跨国业务将其用于异步通信，搜索，社交网络活动流，数据管道，甚至在其交易流程中。随着我们的贸易业务吞吐量的增加，源自我们的消息传递集群的压力也变得迫切。 为什么选择RocketMQ？根据我们的研究，随着使用的队列和虚拟主题的增加，ActiveMQ IO模块遇到了瓶颈。我们尽力通过节流，断路器或降级解决这个问题，但效果不佳。因此，我们开始关注当时流行的消息传递解决方案Kafka。不幸的是，Kafka无法满足我们的要求，特别是在低延迟和高可靠性方面，详见此处。 在这种情况下，我们决定发明一种新的消息传递引擎来处理更广泛的用例，从传统的发布/子场景到大容量实时零容量容错事务系统。我们相信这个解决方案可能是有益的，所以我们希望将它开源给社区。如今，有超过100家公司在其业务中使用RocketMQ的开源版本。我们还发布了基于RocketMQ的商业发行版，这是一种名为阿里巴巴ONS的PaaS产品。 下表演示了RocketMQ，ActiveMQ和Kafka（根据awesome-java的Apache最流行的消息传递解决方案）之间的比较： RocketMQ vs. ActiveMQ vs. Kafka请注意，本文档由RocketMQ团队撰写。虽然理想是技术和功能的无私比较，但作者的专业知识和偏见显然有利于RocketMQ。 下表是一个方便的快速参考，用于一目了然地发现RocketMQ及其最受欢迎的替代品之间的差异。 消息产品 客户端SDK 协议和规范 消息顺序 定时消息 批量消息 广播消息 消息过滤 服务器触发重新传递 消息存储 消息追溯 消息优先级 高可用性和故障转移 消息跟踪 配置 管理和操作工具 ActiveMQ Java，.NET，C ++等 推模型，支持OpenWire，STOMP，AMQP，MQTT，JMS 独家消费者或独家排队可以确保顺序 支持的 不支持 支持的 支持的 不支持 使用JDBC和高性能日志（如levelDB，kahaDB）支持非常快速的持久性 支持的 支持的 支持，根据存储，如果使用kahadb，则需要ZooKeeper服务器 不支持 默认配置为低级别，用户需要优化配置参数 支持的 卡夫卡 Java，Scala等 拉模型，支持TCP 确保在分区内对消息进行排序 不支持 支持，使用异步生产者 不支持 支持，您可以使用Kafka Streams过滤邮件 不支持 高性能文件存储 支持的偏移量表示 不支持 支持，需要ZooKeeper服务器 不支持 Kafka使用键值对格式进行配置。可以从文件或以编程方式提供这些值。 支持，使用terminal命令公开核心指标 RocketMQ Java，C ++，Go 拉模型，支持TCP，JMS，OpenMessaging 确保严格的消息排序，并可以优雅地扩展 支持的 支持，使用同步模式以避免消息丢失 支持的 支持的基于SQL92的属性过滤器表达式 支持的 高性能和低延迟的文件存储 支持的时间戳和偏移量2表示 不支持 支持的Master-Slave模型，没有其他套件 支持的 开箱即用，用户只需要注意几个配置 支持的富Web和终端命令，用于公开核心指标 转自：https://rocketmq.apache.org/docs/motivation/]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
        <tag>mq</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发]]></title>
    <url>%2F2019%2Fconcurrence%2F</url>
    <content type="text"><![CDATA[翻译整理标注，原文来自官方文档 并发Java平台的设计初衷就是为了支持并发编程，在Java编程语言和Java类库中提供基本的并发支持。从5.0版开始，Java平台还包含高级并发API。 进程和线程在并发编程中，有两个基本的执行单元：进程和线程。在Java编程语言中，并发编程主要涉及线程。 计算机系统通常具有许多活动进程和线程。即使在只有一个执行核心的系统中也是如此，因此在任何给定时刻只有一个线程实际执行。通过称为时间切片的OS功能，在进程和线程之间共享单个核心的处理时间。 对于具有多个处理器或具有多个执行核心的处理器的计算机系统来说，处理更加自然。这极大地增强了系统并发执行进程和线程的能力 - 但即使在没有多个处理器或执行核心的简单系统上也可以实现并发。进程 进程具有自包含的执行环境。进程通常具有完整的私有基本运行时资源集; 特别是，每个进程都有自己的内存空间。 进程通常被视为程序或应用程序的同义词。但是，用户看到的单个应用程序实际上可能是一组协作进程。为了促进进程之间的通信，大多数操作系统都支持进程间通信（IPC）资源，例如管道和套接字。IPC不仅用于同一系统上的进程之间的通信，而且还用于不同系统上的进程。 Java虚拟机的大多数实现都作为单个进程运行。Java应用程序可以使用ProcessBuilder对象创建其他进程 线程 线程有时被称为轻量级进程。进程和线程都提供执行环境，但创建新线程所需的资源更少。 线程存在于进程中 - 每个进程至少有一个进程。线程共享进程的资源，包括内存和打开文件。这使得有效但可能有问题的通信成为可能。 多线程执行是Java平台的基本特性。每个应用程序至少有一个线程 - 或几个，如果你计算“系统”线程，它们执行内存管理和信号处理等操作。但是从应用程序员的角度来看，你只从一个线程开始，称为主线程。该线程具有创建其他线程的能力。 线程对象每个线程都与该类的实例相关联 Thread。使用Thread对象创建并发应用程序有两种基本策略。 要直接控制线程创建和管理，只需Thread在应用程序每次启动异步任务时进行实例化。 要从应用程序的其余部分抽象线程管理，请将应用程序的任务传递给执行程序。 定义和启动线程创建线程的两个方法： 提供一个Runnable对象。该 Runnable接口定义了一个方法，run，意在包含在线程执行的代码。该Runnable对象被传递给Thread构造函数，如 HelloRunnable示例所示： 1234567891011public class HelloRunnable implements Runnable &#123; public void run() &#123; System.out.println(&quot;Hello from a thread!&quot;); &#125; public static void main(String args[]) &#123; (new Thread(new HelloRunnable())).start(); &#125;&#125; 拓展Thread。在Thread类本身实现了Runnable，虽然它的run方法不起作用。应用程序可以子类化Thread，提供自己的实现run，如 HelloThread示例中所示： 1234567891011public class HelloThread extends Thread &#123; public void run() &#123; System.out.println(&quot;Hello from a thread!&quot;); &#125; public static void main(String args[]) &#123; (new HelloThread()).start(); &#125;&#125; 请注意，两个示例都会调用Thread.start以启动新线程。 你应该使用哪种？第一个使用Runnable对象更为通用，因为该Runnable对象可以继承一个类以外的类Thread。第二个在简单的应用程序中更容易使用，但受到任务类必须是后代的限制Thread。这里重点介绍第一种方法，该方法将Runnable任务与Thread执行任务的对象分开。这种方法不仅更灵活，而且适用于后面介绍的高级线程管理API。 Thread类定义了大量的线程管理的方法。这些static方法包括提供有关调用方法的线程的信息或影响其状态的方法。从管理线程和Thread对象所涉及的其他线程调用其他方法。我们将在以下部分中研究其中一些方法。 暂停执行与睡眠Thread.sleep可以使当前线程暂停执行。这是使处理器时间可用于应用程序的其他线程或其他应用程序的有效方法。 提供了两个重载版本sleep：一个指定睡眠时间为毫秒，另一个为纳秒。但是，这些睡眠时间并不保证精确，因为它们受到底层操作系统的限制。此外，睡眠周期可以通过中断终止，我们将在后面看到。在任何情况下，您都不能假设调用sleep将在指定的时间段内暂停线程。 该 SleepMessages示例用于sleep以四秒为间隔打印消息： 1234567891011121314151617181920public class SleepMessages &#123; public static void main(String args[]) throws InterruptedException &#123; String importantInfo[] = &#123; &quot;Mares eat oats&quot;, &quot;Does eat oats&quot;, &quot;Little lambs eat ivy&quot;, &quot;A kid will eat ivy too&quot; &#125;; for (int i = 0; i &lt; importantInfo.length; i++) &#123; //Pause for 4 seconds Thread.sleep(4000); //Print a message System.out.println(importantInfo[i]); &#125; &#125;&#125; 请注意，main声明它throws InterruptedException。当另一个线程在sleep活动时中断当前线程时，抛出此异常。由于此程序尚未定义另一个引起中断的线程，因此无需捕获InterruptedException。 中断一个中断是一个指示线程它应该终止它在做的和将要做的。由程序员决定线程如何响应，但一般是终止线程。 通过调用interrupt可以进行中断。为使中断机制正常工作，被中断的线程必须支持自己的中断。 支持中断 线程如何支持自己的中断？如果线程经常调用抛出InterruptedException的方法，它只是简单返回。例如，假设示例中SleepMessages的run方法中Runnable。然后可以按如下方式修改以支持中断： 1234567891011for (int i = 0; i &lt; importantInfo.length; i++) &#123; // Pause for 4 seconds try &#123; Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; // We&apos;ve been interrupted: no more messages. return; &#125; // Print a message System.out.println(importantInfo[i]);&#125; 许多方法抛出InterruptedException，例如sleep，设计为取消当前操作并在收到中断时立即返回。 如果一个线程长时间没有调用抛出InterruptedException的方法怎么办？那么它必须定期调用Thread.interrupted，如果收到中断则返回。例如： 1234567for (int i = 0; i &lt; inputs.length; i++) &#123; heavyCrunch(inputs[i]); if (Thread.interrupted()) &#123; // We&apos;ve been interrupted: no more crunching. return; &#125;&#125; 在这个简单的例子中，代码只是测试中断并退出线程（如果收到）。在更复杂的应用程序中，更可能会抛出有意义的InterruptedException： 123if (Thread.interrupted()) &#123; throw new InterruptedException();&#125; 这允许中断处理集中在一个catch子句中。 中断状态标志 中断机制使用称为中断状态的内部标志来实现。调用Thread.interrupt设置此标志。当线程通过调用静态方法检查中断时Thread.interrupted，中断状态被清除。非静态isInterrupted方法（一个线程用于查询另一个线程的中断状态）不会更改中断状态标志。 按照惯例，任何通过抛出InterruptedException都会清除中断状态。但是，通过另一个线程调用interrupt，立即再次设置中断状态。 Joins该join方法允许一个线程等待另一个线程的完成。如果t是Thread其线程当前正在执行的对象，t.join（）;导致当前线程暂停执行，直到t线程终止。重载join允许程序员指定等待期。但是，如同sleep，join取决于操作系统的计时，所以你不应该假设join只要你指定就等待。 就像sleep，join通过退出来响应中断InterruptedException。 SimpleThreads示例以下示例汇总了本节的一些概念。 SimpleThreads由两个线程组成。第一个是每个Java应用程序都有的主线程。主线程从Runnable对象创建一个新线程MessageLoop，并等待它完成。如果MessageLoop线程需要很长时间才能完成，主线程会中断它。 该MessageLoop线程打印出一系列消息。如果在打印完所有消息之前中断，则MessageLoop线程会打印一条消息并退出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//@see com.example.zjz.javaconcurrence.demo.SimpleThreadspublic class SimpleThreads &#123; // Display a message, preceded by // the name of the current thread static void threadMessage(String message) &#123; String threadName = Thread.currentThread().getName(); System.out.format(&quot;%s: %s%n&quot;, threadName, message); &#125; private static class MessageLoop implements Runnable &#123; public void run() &#123; String importantInfo[] = &#123; &quot;Mares eat oats&quot;, &quot;Does eat oats&quot;, &quot;Little lambs eat ivy&quot;, &quot;A kid will eat ivy too&quot; &#125;; try &#123; for (int i = 0; i &lt; importantInfo.length; i++) &#123; // Pause for 4 seconds Thread.sleep(4000); // Print a message threadMessage(importantInfo[i]); &#125; &#125; catch (InterruptedException e) &#123; threadMessage(&quot;I wasn&apos;t done!&quot;); &#125; &#125; &#125; public static void main(String args[]) throws InterruptedException &#123; // Delay, in milliseconds before // we interrupt MessageLoop // thread (default one hour). long patience = 1000 * 60 * 60; // If command line argument // present, gives patience // in seconds. if (args.length &gt; 0) &#123; try &#123; patience = Long.parseLong(args[0]) * 1000; &#125; catch (NumberFormatException e) &#123; System.err.println(&quot;Argument must be an integer.&quot;); System.exit(1); &#125; &#125; threadMessage(&quot;Starting MessageLoop thread&quot;); long startTime = System.currentTimeMillis(); Thread t = new Thread(new MessageLoop()); t.start(); threadMessage(&quot;Waiting for MessageLoop thread to finish&quot;); // loop until MessageLoop // thread exits while (t.isAlive()) &#123; threadMessage(&quot;Still waiting...&quot;); // Wait maximum of 1 second // for MessageLoop thread // to finish. t.join(1000); if (((System.currentTimeMillis() - startTime) &gt; patience) &amp;&amp; t.isAlive()) &#123; threadMessage(&quot;Tired of waiting!&quot;); t.interrupt(); // Shouldn&apos;t be long now // -- wait indefinitely t.join(); &#125; &#125; threadMessage(&quot;Finally!&quot;); &#125;&#125; 同步线程主要通过共享对字段的访问和引用字段引用的对象进行通信。这种通信形式非常有效，但可能出现两种错误：线程干扰和内存一致性错误。防止这些错误所需的工具是同步。 但是，同步可能会引入线程竞争，当两个或多个线程同时尝试访问同一资源并导致Java运行时更慢地执行一个或多个线程，甚至暂停执行时，会发生线程竞争。 饥饿和活锁是线程竞争的形式。 本节包括以下主题： 线程干扰 描述了当多个线程访问共享数据时如何引入错误。 内存一致性错误 描述了由共享内存的不一致视图导致的错误。 同步方法 描述了一种简单的习惯用法，可以有效地防止线程干扰和内存一致性错误。 隐式锁定和同步 描述了更通用的同步习惯用法，并描述了同步基于隐式锁定的方式。 Atomic Access 讨论了其他线程无法干扰的操作的一般概念。 线程干扰（Thread Interference）考虑一个叫做的简单类 Counter 12345678910111213141516class Counter &#123; private int c = 0; public void increment() &#123; c++; &#125; public void decrement() &#123; c--; &#125; public int value() &#123; return c; &#125;&#125; Counter的设计是为了每次调用increment都会c加1 ，每次调用decrement都会从中减去1 。但是，如果Counter从多个线程引用对象，则线程之间的干扰可能会阻止这种情况按预期发生。 当两种操作，在不同的线程运行，但作用于同一数据的干扰情况。这意味着这两个操作由多个步骤组成，并且步骤序列重叠。 Counter对于交错实例的操作似乎不太可能，因为两个操作c都是单个简单的语句。但是，即使是简单的语句也可以由虚拟机转换为多个步骤。我们不会检查虚拟机采取的具体步骤 - 只需知道单个表达式c**可以分解为三个步骤： 检索当前值c。 将检索的值增加1。 将增加的值存储回来c。 表达式c–可以以相同的方式分解，除了第二步减少而不是增量。 假设线程A increment在线程B调用的同时调用decrement。如果初始值为cis 0，则它们的交错操作可能遵循以下顺序： 线程A：检索c。 线程B：检索c。 线程A：增加检索值; 结果是1。 线程B：减少检索值; 结果是-1。 线程A：将结果存储在c中; c现在是1。 线程B：将结果存储在c中; c现在是-1。 线程A的结果丢失，被线程B覆盖。这种特殊的交错只是一种可能性。在不同的情况下，可能是线程B的结果丢失，或者根本没有错误。因为它们是不可预测的，所以难以检测和修复线程干扰错误。 内存一致性错误（Memory Consistency Errors）当不同的线程具有应该是相同数据的不一致视图时，会发生内存一致性错误。内存一致性错误的原因很复杂，超出了本教程的范围。幸运的是，程序员不需要详细了解这些原因。所需要的只是避免它们的策略。 避免内存一致性错误的关键是理解先发生关系（happens-before relationship）。这种关系只是保证一个特定语句的内存写入对另一个特定语句可见。要查看此内容，请考虑以下示例。假设int定义并初始化了一个简单字段： 1int counter = 0; 该counter字段在两个线程A和B之间共享。假设线程A递增counter： 1counter++; 然后，不久之后，线程B打印出来counter： 1System.out.println(counter); 如果两个语句已在同一个线程中执行，则可以安全地假设打印出的值为“1”。但是如果这两个语句是在不同的线程中执行的，那么打印出的值可能是“0”，因为不能保证线程A的更改counter对于线程B是可见的 - 除非程序员在这些之间建立了先发生关系。两个陈述。 有几种行为可以创造先发生过的关系。其中之一是同步，我们将在以下部分中看到。 我们已经看到了两种创造前发生关系的行为。 当一个语句调用时Thread.start，与该语句有一个happens-before关系的每个语句也与新线程执行的每个语句都有一个happens-before关系。新线程可以看到导致创建新线程的代码的影响。 当一个线程终止并导致Thread.join另一个线程返回时，终止线程执行的所有语句与成功连接后的所有语句都有一个happens-before关系。现在，执行连接的线程可以看到线程中代码的效果。 有关创建先发生关系的操作列表，请参阅java.util.concurrent。 同步方法Java编程语言提供了两种基本的同步习惯用法：synchronized方法和synchronized语句。下两节将介绍两个同步语句中较为复杂的语句。本节介绍同步方法。 要使方法同步，只需将synchronized关键字添加到其声明： 123456789101112131415public class SynchronizedCounter &#123; private int c = 0; public synchronized void increment() &#123; c++; &#125; public synchronized void decrement() &#123; c--; &#125; public synchronized int value() &#123; return c; &#125;&#125; 如果count是实例SynchronizedCounter，则使这些方法同步有两个影响： 首先，对同一对象的两个同步方法的调用不可能进行交错。当一个线程正在为对象执行同步方法时，所有其他线程调用同一对象的同步方法（暂停执行）直到第一个线程完成对象。 其次，当同步方法退出时，它会自动与同一对象的同步方法的任何后续调用建立**先发生关系**。这可以保证对所有线程都可以看到对象状态的更改。请注意，构造函数无法同步 - 使用synchronized带有构造函数的关键字是语法错误。同步构造函数没有意义，因为只有创建对象的线程在构造时才能访问它。 警告： 构造将在线程之间共享的对象时，要非常小心，对对象的引用不会过早“泄漏”。例如，假设您要维护一个包含每个类实例的List调用instances。您可能想要将以下行添加到构造函数中：1instances.add(this); 但是其他线程可以instances在构造对象完成之前用来访问对象。 同步方法支持一种简单的策略来防止线程干扰和内存一致性错误：如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过synchronized方法完成的。（一个重要的例外：final在构造对象之后无法修改的字段，一旦构造了对象，就可以通过非同步方法安全地读取）这种策略是有效的，但是可能会带来性能问题。 内部锁定和同步同步是围绕称为内部锁或监视器锁的内部实体构建的。（API规范通常将此实体简称为“监视器（monitor）”。）内部锁在同步的两个方面都发挥作用：强制对对象状态进行独占访问，并建立对可见性至关重要的先发生关系（happens-before relationships）。 每个对象都有一个与之关联的内部锁。按照惯例，需要对对象字段进行独占和一致访问的线程必须在访问对象之前获取对象的内部锁，然后在完成它们时释放内部锁。据说一个线程在获得锁定和释放锁定之间拥有内在锁定。只要一个线程拥有一个内部锁，没有其他线程可以获得相同的锁。另一个线程在尝试获取锁时将阻塞。 当线程释放内部锁时，在该操作与同一锁的任何后续获取之间建立先发生关系。 锁定同步方法 当线程调用synchronized方法时，它会自动获取该方法对象的内部锁，并在方法返回时释放它。即使返回是由未捕获的异常引起的，也会发生锁定释放。 您可能想知道在调用静态同步方法时会发生什么，因为静态方法与类关联，而不是与对象关联。在这种情况下，线程获取Class与类关联的对象的内部锁。因此，对类的静态字段的访问由与该类的任何实例的锁不同的锁控制。 同步语句 创建同步代码的另一种方法是使用synchronized语句。与synchronized方法不同，synchronized语句必须指定提供内部锁的对象： 1234567public void addName(String name) &#123; synchronized(this) &#123; lastName = name; nameCount++; &#125; nameList.add(name);&#125; 在该示例中，addName方法需要同步变化lastName和nameCount，还需要避免的其他对象的方法同步调用。（从同步代码调用其他对象的方法可能会产生在Liveness一节中描述的问题。）如果没有synchronized语句，则必须有一个单独的，不同步的方法，仅用于调用nameList.add。 同步语句对于通过细粒度同步 提高并发性也很有用。例如，假设class MsLunch有两个实例字段，c1并且c2从不一起使用。必须同步这些字段的所有更新，但没有理由阻止c1的更新与c2的更新交错 - 这样做会通过创建不必要的阻塞来减少并发性。this我们创建两个对象仅用于提供锁，而不是使用同步方法或以其他方式使用与之关联的锁。 123456789101112131415161718public class MsLunch &#123; private long c1 = 0; private long c2 = 0; private Object lock1 = new Object(); private Object lock2 = new Object(); public void inc1() &#123; synchronized(lock1) &#123; c1++; &#125; &#125; public void inc2() &#123; synchronized(lock2) &#123; c2++; &#125; &#125;&#125; 谨慎使用。您必须绝对确保对受影响字段的访问进行交错是否安全。 可重入同步（Reentrant Synchronization） 回想一下，线程无法获取另一个线程拥有的锁。但是，一个线程可以获取它已经拥有的锁。允许线程多次获取相同的锁可启用重入同步。这描述了一种情况，其中同步代码直接或间接地调用也包含同步代码的方法，并且两组代码使用相同的锁。在没有可重入同步的情况下，同步代码必须采取许多额外的预防措施，以避免线程导致自身阻塞。 原子访问在编程中，原子动作是一次有效发生的动作。原子动作不能在中间停止：它要么完全发生，要么根本不发生。在动作完成之前，原子动作的副作用是不可见的。 我们已经看到增量表达式，例如c++，没有描述原子动作。即使非常简单的表达式也可以定义可以分解为其他操作的复杂操作。但是，您可以确定下列原子操作： 读取和写入对于引用变量和大多数原始变量（除了long和double之外的所有类型）都是原子的。 读取和写入对于声明的所有变量volatile（包括 long和double变量）都是原子的。 原子动作不能交错，因此可以使用它们而不必担心线程干扰。但是，这并不能消除所有同步原子操作的需要，因为仍然可能存在内存一致性错误。使用volatile变量可以降低内存一致性错误的风险，因为对volatile变量的任何写入都会建立与之后读取同一变量的先发生关系。这意味着对volatile变量的更改始终对其他线程可见。更重要的是，它还意味着当一个线程读取一个volatile变量时，它不仅会看到最新的变化volatile，而且还会看到导致变化的代码的副作用。 使用简单的原子变量访问比通过同步代码访问这些变量更有效，但程序员需要更加小心以避免内存一致性错误。额外的努力是否值得取决于应用程序的大小和复杂性。 包中的某些类 java.util.concurrent提供了不依赖于同步的原子方法。 活跃度（Liveness） 并发应用程序及时执行的能力被称为其活跃性。本节描述了最常见的活动问题，即死锁，并继续简要描述其他两个活动问题，饥饿和活锁。 死锁死锁描述了两个或多个线程永远被阻塞，等待彼此的情况。这是一个例子。 阿方斯和加斯顿是朋友，他们都很有礼貌。严格的礼貌规则是，当你向朋友鞠躬时，你必须保持鞠躬，直到你的朋友有机会还礼。不幸的是，这条规则没有考虑到两个朋友可能同时互相鞠躬的可能性。这个示例应用程序 Deadlock模拟了这种可能性： 123456789101112131415161718192021222324252627282930313233343536//@see com.example.zjz.javaconcurrence.demo.Deadlockpublic class Deadlock &#123; static class Friend &#123; private final String name; public Friend(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; public synchronized void bow(Friend bower) &#123; System.out.format(&quot;%s: %s&quot; + &quot; has bowed to me!%n&quot;, this.name, bower.getName()); bower.bowBack(this); &#125; public synchronized void bowBack(Friend bower) &#123; System.out.format(&quot;%s: %s&quot; + &quot; has bowed back to me!%n&quot;, this.name, bower.getName()); &#125; &#125; public static void main(String[] args) &#123; final Friend alphonse = new Friend(&quot;Alphonse&quot;); final Friend gaston = new Friend(&quot;Gaston&quot;); new Thread(new Runnable() &#123; public void run() &#123; alphonse.bow(gaston); &#125; &#125;).start(); new Thread(new Runnable() &#123; public void run() &#123; gaston.bow(alphonse); &#125; &#125;).start(); &#125;&#125; 当Deadlock运行时，这是非常有可能的是，当他们尝试调用两个线程将被阻塞bowBack。这两个块都不会结束，因为每个线程都在等待另一个线程退出bow。 饥饿和活锁饥饿和活锁没有死锁常见，但仍然是每个并发软件设计者可能遇到的问题。 饥饿 Starvation描述了一种情况，即线程无法定期访问共享资源，并且无法运行。当“贪婪”线程使共享资源长时间不可用时会发生这种情况。例如，假设一个对象提供了一个通常需要很长时间才能返回的同步方法。如果一个线程经常调用此方法，则通常还需要阻止对同一对象进行频繁同步访问的其他线程。 活锁 线程通常用于响应另一个线程的操作。如果另一个线程的操作也是对另一个线程的操作的响应，则可能导致活锁。与死锁一样，活锁线程无法取得进一步进展。但是，线程没有被阻塞- 它们只是太忙于相互响应以恢复工作。这相当于两个试图在走廊里互相通过的人：Alphonse向左移动让Gaston通过，而Gaston向右移动让Alphonse通过。看到他们仍在相互阻挡，Alphone向右移动，而Gaston向左移动。他们还在互相阻挡，所以…… 守卫块（Guarded Blocks）线程通常必须协调他们的行为。最常见的协调习语是守卫块。这样的块开始于在块可以继续之前轮询必须为真的条件。要正确执行此操作，需要执行许多步骤。 例如，假设guardedJoy一个方法joy在另一个线程设置共享变量之前不得继续。理论上，这种方法可以简单地循环直到满足条件，但该循环是浪费的，因为它在等待时连续执行。 123456public void guardedJoy() &#123; // Simple loop guard. Wastes // processor time. Don&apos;t do this! while(!joy) &#123;&#125; System.out.println(&quot;Joy has been achieved!&quot;);&#125; 一个更有效的守卫调用 Object.wait暂停当前线程。在wait另一个线程发出可能发生某些特殊事件的通知之前，调用不会返回 - 尽管不一定是此线程正在等待的事件： 12345678910public synchronized void guardedJoy() &#123; // This guard only loops once for each special event, which may not // be the event we&apos;re waiting for. while(!joy) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123;&#125; &#125; System.out.println(&quot;Joy and efficiency have been achieved!&quot;);&#125; 注意： wait始终在测试等待条件的循环内调用。不要假设中断是针对您正在等待的特定条件，或者条件仍然是真的。 像许多暂停执行的方法一样，wait可以抛出InterruptedException。在这个例子中，我们可以忽略该异常 - 我们只关心它的值joy。 为什么这个版本guardedJoy要同步？假设d是我们用来调用的对象wait。当线程调用时d.wait，它必须拥有内部锁d- 否则会引发错误。wait在synchronized方法中调用是获取内部锁的简单方法。 当wait被调用时，线程释放锁，并暂停执行。在将来的某个时间，另一个线程将获取相同的锁并调用 Object.notifyAll，通知等待该锁的所有线程发生了重要的事情： 1234public synchronized notifyJoy() &#123; joy = true; notifyAll();&#125; 在第二个线程释放锁之后的一段时间，第一个线程重新获取锁并通过从调用返回来恢复wait。 注意： 有第二种通知方法notify，可以唤醒单个线程。因为notify不允许您指定被唤醒的线程，所以它仅在大规模并行应用程序中有用 - 即具有大量线程的程序，所有程序都执行类似的工作。在这样的应用程序中，您不关心哪个线程被唤醒。 让我们使用受保护的块来创建Producer-Consumer应用程序。这种应用程序在两个线程之间共享数据：生成器，创建数据，以及使用它的消费者。两个线程使用共享对象进行通信。协调是必不可少的：消费者线程不得在生产者线程交付之前尝试检索数据，并且如果消费者未检索旧数据，则生产者线程不得尝试传递新数据。 在此示例中，数据是一系列文本消息，通过以下类型的对象共享 Drop： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Drop &#123; // Message sent from producer // to consumer. private String message; // True if consumer should wait // for producer to send message, // false if producer should wait for // consumer to retrieve message. private boolean empty = true; public synchronized String take() &#123; // Wait until message is // available. while (empty) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123;&#125; &#125; // Toggle status. empty = true; // Notify producer that // status has changed. notifyAll(); return message; &#125; public synchronized void put(String message) &#123; // Wait until message has // been retrieved. while (!empty) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123;&#125; &#125; // Toggle status. empty = false; // Store message. this.message = message; // Notify consumer that status // has changed. notifyAll(); &#125;&#125; 定义的生产者线程 Producer发送一系列熟悉的消息。字符串“DONE”表示已发送所有消息。为了模拟真实世界应用程序的不可预测性，生产者线程暂停消息之间的随机间隔。 1234567891011121314151617181920212223242526272829import java.util.Random;public class Producer implements Runnable &#123; private Drop drop; public Producer(Drop drop) &#123; this.drop = drop; &#125; public void run() &#123; String importantInfo[] = &#123; &quot;Mares eat oats&quot;, &quot;Does eat oats&quot;, &quot;Little lambs eat ivy&quot;, &quot;A kid will eat ivy too&quot; &#125;; Random random = new Random(); for (int i = 0; i &lt; importantInfo.length; i++) &#123; drop.put(importantInfo[i]); try &#123; Thread.sleep(random.nextInt(5000)); &#125; catch (InterruptedException e) &#123;&#125; &#125; drop.put(&quot;DONE&quot;); &#125;&#125; 定义的消费者线程 Consumer只是检索消息并将其打印出来，直到它检索到“DONE”字符串。该线程也会暂停随机间隔。 123456789101112131415161718192021import java.util.Random;public class Consumer implements Runnable &#123; private Drop drop; public Consumer(Drop drop) &#123; this.drop = drop; &#125; public void run() &#123; Random random = new Random(); for (String message = drop.take(); ! message.equals(&quot;DONE&quot;); message = drop.take()) &#123; System.out.format(&quot;MESSAGE RECEIVED: %s%n&quot;, message); try &#123; Thread.sleep(random.nextInt(5000)); &#125; catch (InterruptedException e) &#123;&#125; &#125; &#125;&#125; 最后，这里是定义的主线程 ProducerConsumerExample，用于启动生产者和消费者线程。 1234567public class ProducerConsumerExample &#123; public static void main(String[] args) &#123; Drop drop = new Drop(); (new Thread(new Producer(drop))).start(); (new Thread(new Consumer(drop))).start(); &#125;&#125; 注： 该Drop被写入以证明保护块。为避免重新发明轮子，请在尝试编写自己的数据共享对象之前检查Java Collections Framework中的现有数据结构 。 不可变对象如果一个对象的状态在构造后不能改变，则该对象被认为是不可变的。最大程度上依赖不可变对象被广泛接受为创建简单，可靠代码的合理策略。 不可变对象在并发应用程序中特别有用。由于它们不能改变状态，因此它们不会被线程干扰破坏或在不一致状态下被观察到。 程序员通常不愿意使用不可变对象，因为他们担心创建新对象的成本而不是更新对象。对象创建的影响经常被高估，并且可以通过与不可变对象相关联的一些效率来抵消。这些包括由于垃圾收集而减少的开销，以及消除保护可变对象免于损坏所需的代码。 以下小节采用其实例可变的类，并从中派生出具有不可变实例的类。通过这样做，它们为这种转换提供了一般规则，并展示了不可变对象的一些优点。 同步类示例该类 SynchronizedRGB定义了表示颜色的对象。每个对象将颜色表示为代表主要颜色值的三个整数和一个给出颜色名称的字符串。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class SynchronizedRGB &#123; // Values must be between 0 and 255. private int red; private int green; private int blue; private String name; private void check(int red, int green, int blue) &#123; if (red &lt; 0 || red &gt; 255 || green &lt; 0 || green &gt; 255 || blue &lt; 0 || blue &gt; 255) &#123; throw new IllegalArgumentException(); &#125; &#125; public SynchronizedRGB(int red, int green, int blue, String name) &#123; check(red, green, blue); this.red = red; this.green = green; this.blue = blue; this.name = name; &#125; public void set(int red, int green, int blue, String name) &#123; check(red, green, blue); synchronized (this) &#123; this.red = red; this.green = green; this.blue = blue; this.name = name; &#125; &#125; public synchronized int getRGB() &#123; return ((red &lt;&lt; 16) | (green &lt;&lt; 8) | blue); &#125; public synchronized String getName() &#123; return name; &#125; public synchronized void invert() &#123; red = 255 - red; green = 255 - green; blue = 255 - blue; name = &quot;Inverse of &quot; + name; &#125;&#125; SynchronizedRGB必须小心使用，以免被发现处于不一致状态。例如，假设一个线程执行以下代码： 12345SynchronizedRGB color = new SynchronizedRGB(0, 0, 0, &quot;Pitch Black&quot;);...int myColorInt = color.getRGB(); //Statement 1String myColorName = color.getName(); //Statement 2 如果另一个线程color.set在语句1之后但在语句2之前调用，则其值myColorInt将与值不匹配myColorName。为了避免这种结果，必须将这两个语句绑定在一起： 1234synchronized (color) &#123; int myColorInt = color.getRGB(); String myColorName = color.getName();&#125; 这种不一致性只适用于可变对象 - 对于不可变版本的SynchronizedRGB来说，它不会成为问题。 一种定义不可变对象的策略以下规则定义了用于创建不可变对象的简单策略。并非所有记录为“不可变”的类都遵循这些规则。这并不一定意味着这些类的创造者是草率的 - 他们可能有充分的理由相信他们的类实例在建造后永远不会改变。但是，这种策略需要复杂的分析，不适合初学者。 不要提供“setter”方法 - 修改字段引用的字段或对象的方法。 使所有字段final和private。 不允许子类重写方法。最简单的方法是将类声明为final。更复杂的方法是private在工厂方法中构造构造函数和构造实例。 如果实例字段包含对可变对象的引用，则不允许更改这些对象： 不要提供修改可变对象的方法。 不要共享对可变对象的引用。永远不要存储对传递给构造函数的外部可变对象的引用; 如有必要，创建副本并存储对副本的引用。同样，必要时创建内部可变对象的副本，以避免在方法中返回原始对象。 将此策略应用于SynchronizedRGB以下步骤： 这个类中有两个setter方法。第一个，set任意转换对象，并且在类的不可变版本中没有位置。第二个，invert可以通过让它创建一个新对象而不是修改现有对象来进行调整。 所有领域都已经存在private; 他们进一步被认定为final。 类本身已声明final。 只有一个字段引用一个对象，该对象本身是不可变的。因此，不需要防止改变“包含的”可变对象的状态的保护措施。在这些变化之后，我们有 ImmutableRGB： 123456789101112131415161718192021222324252627282930313233343536373839404142434445final public class ImmutableRGB &#123; // Values must be between 0 and 255. final private int red; final private int green; final private int blue; final private String name; private void check(int red, int green, int blue) &#123; if (red &lt; 0 || red &gt; 255 || green &lt; 0 || green &gt; 255 || blue &lt; 0 || blue &gt; 255) &#123; throw new IllegalArgumentException(); &#125; &#125; public ImmutableRGB(int red, int green, int blue, String name) &#123; check(red, green, blue); this.red = red; this.green = green; this.blue = blue; this.name = name; &#125; public int getRGB() &#123; return ((red &lt;&lt; 16) | (green &lt;&lt; 8) | blue); &#125; public String getName() &#123; return name; &#125; public ImmutableRGB invert() &#123; return new ImmutableRGB(255 - red, 255 - green, 255 - blue, &quot;Inverse of &quot; + name); &#125;&#125; 高级并发对象到目前为止，本课程重点关注从一开始就是Java平台一部分的低级API。这些API适用于非常基本的任务，但更高级的任务需要更高级别的构建块。对于充分利用当今多处理器和多核系统的大规模并发应用程序尤其如此。 在本节中，我们将介绍Java平台5.0版中引入的一些高级并发功能。大多数这些功能都在新java.util.concurrent包中实现。Java Collections Framework中还有新的并发数据结构。 锁对象支持锁定习惯用法，简化了许多并发应用程序。 执行程序定义用于启动和管理线程的高级API。提供的执行程序实现提供java.util.concurrent适用于大规模应用程序的线程池管理。 并发集合使管理大量数据更容易，并且可以大大减少同步需求。 原子变量具有最小化同步的功能，有助于避免内存一致性错误。 ThreadLocalRandom （在JDK 7中）提供了从多个线程有效生成伪随机数。 锁对象（Lock Objects）同步代码依赖于一种简单的可重入锁定。这种锁易于使用，但有许多限制。java.util.concurrent.locks包装支持更复杂的锁定习语 。我们不会详细介绍这个包，而是将重点放在它最基本的接口上 Lock。 Lock对象的工作方式与同步代码使用的隐式锁非常相似。与隐式锁一样，一次只有一个线程可以拥有一个Lock对象。Lock对象还通过其关联Condition对象支持wait/notify机制。 Lock对象相对于隐式锁定的最大优点是它们能够退出获取锁定的尝试。tryLock如果锁定立即不可用或超时到期之前（如果指定），则该方法退出。lockInterruptibly如果另一个线程在获取锁之前发送中断，则该方法退出。 让我们使用Lock对象来解决我们在Liveness中看到的死锁问题。当朋友即将鞠躬时，阿方斯和加斯顿已经训练自己注意到了。我们通过要求我们的Friend对象必须在继续执行弓之前获取两个参与者的锁来模拟这种改进。以下是改进模型的源代码 Safelock。为了证明这个习语的多样性，我们假设阿尔方斯和加斯顿如此迷恋他们新发现的安全鞠躬能力，他们不能停止相互鞠躬： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.Random;public class Safelock &#123; static class Friend &#123; private final String name; private final Lock lock = new ReentrantLock(); public Friend(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; public boolean impendingBow(Friend bower) &#123; Boolean myLock = false; Boolean yourLock = false; try &#123; myLock = lock.tryLock(); yourLock = bower.lock.tryLock(); &#125; finally &#123; if (! (myLock &amp;&amp; yourLock)) &#123; if (myLock) &#123; lock.unlock(); &#125; if (yourLock) &#123; bower.lock.unlock(); &#125; &#125; &#125; return myLock &amp;&amp; yourLock; &#125; public void bow(Friend bower) &#123; if (impendingBow(bower)) &#123; try &#123; System.out.format(&quot;%s: %s has&quot; + &quot; bowed to me!%n&quot;, this.name, bower.getName()); bower.bowBack(this); &#125; finally &#123; lock.unlock(); bower.lock.unlock(); &#125; &#125; else &#123; System.out.format(&quot;%s: %s started&quot; + &quot; to bow to me, but saw that&quot; + &quot; I was already bowing to&quot; + &quot; him.%n&quot;, this.name, bower.getName()); &#125; &#125; public void bowBack(Friend bower) &#123; System.out.format(&quot;%s: %s has&quot; + &quot; bowed back to me!%n&quot;, this.name, bower.getName()); &#125; &#125; static class BowLoop implements Runnable &#123; private Friend bower; private Friend bowee; public BowLoop(Friend bower, Friend bowee) &#123; this.bower = bower; this.bowee = bowee; &#125; public void run() &#123; Random random = new Random(); for (;;) &#123; try &#123; Thread.sleep(random.nextInt(10)); &#125; catch (InterruptedException e) &#123;&#125; bowee.bow(bower); &#125; &#125; &#125; public static void main(String[] args) &#123; final Friend alphonse = new Friend(&quot;Alphonse&quot;); final Friend gaston = new Friend(&quot;Gaston&quot;); new Thread(new BowLoop(alphonse, gaston)).start(); new Thread(new BowLoop(gaston, alphonse)).start(); &#125;&#125; 执行者（Executors）在前面的所有示例中，由Runnable对象定义的新线程和由对象定义的线程本身完成的任务之间存在紧密的联系Thread。这适用于小型应用程序，但在大型应用程序中，将线程管理和创建与应用程序的其余部分分开是有意义的。封装这些函数的对象称为执行程序（Executors）。以下小节详细描述了执行程序。 Executor Interfaces定义三个执行器对象类型。 线程池是最常见的执行器实现类型。 Fork / Join是一个利用多个处理器的框架（JDK 7中的新增功能）。 执行器接口该java.util.concurrent包定义了三个执行器接口： Executor，一个支持启动新任务的简单接口。 ExecutorService，Executor的子接口，增加了有助于管理生命周期的功能，包括单个任务和执行程序本身。 ScheduledExecutorService，ExecutorService的子接口，支持未来和/或定期执行任务。 通常，引用executor对象的变量被声明为这三种接口类型之一，而不是执行器类类型。 Executor Executor接口提供了一种方法，execute旨在成为常见的线程创建习惯用语的替代品。如果r是Runnable对象，e则Executor可以替换为对象 1(new Thread(r)).start(); 同 1e.execute(r); 但是，定义execute不太具体。低级习语创建一个新线程并立即启动它。根据Executor实现，execute可能会执行相同的操作，但更有可能使用现有的工作线程来运行r，或者放入r队列以等待工作线程变为可用。（我们将在线程池的部分中描述工作线程。） 执行程序实现java.util.concurrent旨在充分利用更高级ExecutorService和ScheduledExecutorService接口，尽管它们也可以与基本Executor接口一起使用。 ExecutorService 该 ExecutorService接口补充了execute相似的，但更通用的submit方法。就像execute，submit接受Runnable对象，但也接受 Callable允许任务返回值的对象。该submit方法返回一个 Future对象，该对象用于检索Callable返回值并管理两者Callable和Runnable任务的状态。 ExecutorService还提供了提交大量Callable对象的方法。最后，ExecutorService提供了许多用于管理执行程序关闭的方法。为了支持立即关闭，任务应该正确处理中断。 ScheduledExecutorService 该 ScheduledExecutorService接口补充其父接口ExecutorService schedule方法 ，其执行Runnable或Callable在指定延迟后的任务。此外，接口定义scheduleAtFixedRate并scheduleWithFixedDelay以规定的间隔重复执行指定的任务。 线程池大多数执行程序实现都在java.util.concurrent使用线程池，它由工作线程组成。这种线程Runnable与Callable它执行的任务分开存在，通常用于执行多个任务。 使用工作线程可以最大限度地减少由于创建线程而产生 线程对象使用的大量内存，而在大型应用程序中，分配和释放许多线程对象会产生大量的内存管理开销。 一种常见类型的线程池是固定线程池。这种类型的池总是运行指定数量的线程; 如果某个线程在仍在使用时以某种方式终止，它将自动替换为新线程。任务通过内部队列提交到池中，只要有多个活动任务而不是线程，该队列就会保存额外的任务。 固定线程池的一个重要优点是使用它的应用程序可以优雅地降级。要理解这一点，请考虑一个Web服务器应用程序，其中每个HTTP请求都由一个单独的线程处理。如果应用程序只为每个新的HTTP请求创建一个新线程，并且系统接收的请求数超过它可以立即处理的数量，那么当所有这些线程的开销超过系统容量时，应用程序将突然停止响应所有请求。由于可以创建的线程数量有限制，应用程序不会像它们进入时那样快速地为HTTP请求提供服务，但它将在系统可以维持的时间内尽快为它们提供服务。 创建使用固定线程池的执行程序的一种简单方法是调用 newFixedThreadPool工厂方法。 java.util.concurrent.Executors此类还提供以下工厂方法： 该 newCachedThreadPool方法使用可扩展线程池创建执行程序。此执行程序适用于启动许多短期任务的应用程序。 该 newSingleThreadExecutor方法创建一次执行单个任务的执行程序。 几种工厂方法是ScheduledExecutorService版本创建上述执行器。 如果上述工厂方法提供的执行者都不满足您的需求，则构建实例 java.util.concurrent.ThreadPoolExecutor或 java.util.concurrent.ScheduledThreadPoolExecutor将为您提供其他选项。 fork / join fork / join框架是ExecutorService接口的实现，可帮助您利用多个处理器。它专为可以递归分解成小块的工作而设计。目标是使用所有可用的处理能力来增强应用程序的性能。 与任何ExecutorService实现一样，fork / join框架将任务分配给线程池中的工作线程。fork / join框架是不同的，因为它使用了工作窃取（work-stealing ）算法。不用做的事情的工作线程可以从仍然忙碌的其他线程中窃取任务。（可以想象递归的操作） fork / join框架的中心是ForkJoinPool类，是 扩展AbstractExecutorService。ForkJoinPool实现核心工作窃取算法并可以执行 ForkJoinTask进程。 基本用法 使用fork / join框架的第一步是编写执行一部分工作的代码。您的代码应类似于以下伪代码： 12345如果（我的工作部分足够小） 直接做这项工作否则 把我的工作分成两部分 调用这两个部分并等待结果 将此代码包装在ForkJoinTask子类中，通常使用其中一种更专业的类型 RecursiveTask（可以返回结果）或 RecursiveAction。 在您的ForkJoinTask子类是准备好了，创建一个表示要完成所有的工作对象，把它传递给一个ForkJoinPool实例的invoke()方法。 模糊为Clarity 为了帮助您了解fork / join框架的工作原理，请考虑以下示例。假设您想模糊图像。原始源图像由整数数组表示，其中每个整数包含单个像素的颜色值。模糊的目标图像也由与源相同大小的整数数组表示。 通过一次一个像素地处理源阵列来完成模糊。每个像素与其周围像素平均（红色，绿色和蓝色分量被平均），结果放在目标数组中。由于图像是大型数组，因此此过程可能需要很长时间。通过使用fork / join框架实现算法，您可以利用多处理器系统上的并发处理。这是一个可能的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ForkBlur extends RecursiveAction &#123; private int[] mSource; private int mStart; private int mLength; private int[] mDestination; // Processing window size; should be odd. private int mBlurWidth = 15; public ForkBlur(int[] src, int start, int length, int[] dst) &#123; mSource = src; mStart = start; mLength = length; mDestination = dst; &#125; protected void computeDirectly() &#123; int sidePixels = (mBlurWidth - 1) / 2; for (int index = mStart; index &lt; mStart + mLength; index++) &#123; // Calculate average. float rt = 0, gt = 0, bt = 0; for (int mi = -sidePixels; mi &lt;= sidePixels; mi++) &#123; int mindex = Math.min(Math.max(mi + index, 0), mSource.length - 1); int pixel = mSource[mindex]; rt += (float)((pixel &amp; 0x00ff0000) &gt;&gt; 16) / mBlurWidth; gt += (float)((pixel &amp; 0x0000ff00) &gt;&gt; 8) / mBlurWidth; bt += (float)((pixel &amp; 0x000000ff) &gt;&gt; 0) / mBlurWidth; &#125; // Reassemble destination pixel. int dpixel = (0xff000000 ) | (((int)rt) &lt;&lt; 16) | (((int)gt) &lt;&lt; 8) | (((int)bt) &lt;&lt; 0); mDestination[index] = dpixel; &#125; &#125; ... 现在实现抽象compute()方法，该方法直接执行模糊或将其拆分为两个较小的任务。简单的数组长度阈值有助于确定是执行还是拆分工作。 1234567891011121314protected static int sThreshold = 100000;protected void compute() &#123; if (mLength &lt; sThreshold) &#123; computeDirectly(); return; &#125; int split = mLength / 2; invokeAll(new ForkBlur(mSource, mStart, split, mDestination), new ForkBlur(mSource, mStart + split, mLength - split, mDestination));&#125; 如果以前的方法在类的子RecursiveAction类中，那么将任务设置为在a中运行ForkJoinPool很简单，并涉及以下步骤： 创建一个代表要完成的所有工作的任务。 123//源图像像素在src中//目标图像像素在dst中ForkBlur fb = new ForkBlur(src, 0, src.length, dst); 创建ForkJoinPool将运行任务的那个。 1ForkJoinPool pool = new ForkJoinPool(); 运行任务。 1pool.invoke(fb); 有关完整源代码，包括一些创建目标映像文件的额外代码，请参阅 ForkBlur示例。 标准实现 除了使用fork / join框架来实现在多处理器系统上同时执行的任务的自定义算法（例如ForkBlur.java上一节中的示例）之外，Java SE中有一些通常有用的功能，它们已经使用fork / join实现了框架。在Java SE 8中引入的一种这样的实现被 java.util.Arrays类用于其parallelSort()方法。这些方法类似于sort()，但通过fork / join框架利用并发性。在多处理器系统上运行时，大型阵列的并行排序比顺序排序更快。但是，这些方法如何利用fork / join框架超出了Java Tutorials的范围。有关此信息，请参阅Java API文档。 fork / join框架的另一个实现由java.util.streams包中的方法使用，该方法是为Java SE 8发布而安排的Project Lambda的一部分。 并发集合该java.util.concurrent软件包包括Java Collections Framework的许多新增功能。这些最容易通过提供的集合接口进行分类： BlockingQueue 定义先进先出数据结构，当您尝试添加到完整队列或从空队列中检索时，该数据结构会阻塞或超时。 ConcurrentMap是java.util.Map定义有用原子操作的子接口 。仅当密钥存在时，这些操作才会删除或替换键值对，或仅在密钥不存在时才添加键值对。使这些操作原子化有助于避免同步。标准的通用实现ConcurrentMap是 ConcurrentHashMap，它是一个并发的模拟 HashMap。 ConcurrentNavigableMap是ConcurrentMap支持近似匹配的子接口。标准的通用实现ConcurrentNavigableMap是 ConcurrentSkipListMap，它是一个并发的模拟 TreeMap。 所有这些集合通过定义将对象添加到集合的操作与访问或删除该对象的后续操作之间的先发生关系来帮助避免内存一致性错误。 原子变量该 java.util.concurrent.atomic包定义了支持单个变量的原子操作的类。所有类都有get和set类似读取和写入volatile变量的方法。也就是说，a set与get同一变量上的任何后续关系具有先发生关系。原子compareAndSet方法也具有这些内存一致性功能，适用于整数原子变量的简单原子算法也是如此。 要查看如何使用此包，让我们返回到 Counter我们最初用于演示线程干扰的类： 12345678910111213141516class Counter &#123; private int c = 0; public void increment() &#123; c++; &#125; public void decrement() &#123; c--; &#125; public int value() &#123; return c; &#125;&#125; 使一种方式Counter安全从线程干扰使其同步的方法，如 SynchronizedCounter： 12345678910111213141516class SynchronizedCounter &#123; private int c = 0; public synchronized void increment() &#123; c++; &#125; public synchronized void decrement() &#123; c--; &#125; public synchronized int value() &#123; return c; &#125;&#125; 对于这个简单的类，同步是可接受的解决方案。但是对于更复杂的类，我们可能希望避免不必要的同步对活动的影响。使用a替换int字段AtomicInteger允许我们在不诉诸同步的情况下防止线程干扰，如 AtomicCounter： 123456789101112131415161718import java.util.concurrent.atomic.AtomicInteger;class AtomicCounter &#123; private AtomicInteger c = new AtomicInteger(0); public void increment() &#123; c.incrementAndGet(); &#125; public void decrement() &#123; c.decrementAndGet(); &#125; public int value() &#123; return c.get(); &#125;&#125; 并发随机数在JDK 7中， java.util.concurrent包括一个便利类， ThreadLocalRandom用于期望使用来自多个线程或ForkJoinTasks的随机数的应用程序。 对于并发访问，使用ThreadLocalRandom而不是Math.random()在较少的争用中获得结果，并最终获得更好的性能。 您需要做的就是调用ThreadLocalRandom.current()，然后调用其中一个方法来检索随机数。这是一个例子： 1int r = ThreadLocalRandom.current() .nextInt(4, 77); 进一步阅读 Java Concurrent Animated：显示并发功能用法的动画。 codegit]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式简介]]></title>
    <url>%2F2019%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[背景 随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 单一应用架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。 垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。 转载自 http://dubbo.apache.org/zh-cn/docs/user/preface/background.html]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线资源]]></title>
    <url>%2F2018%2Fonline-resource%2F</url>
    <content type="text"><![CDATA[VisuAlgo(数据结构和算法动态可视化) jsr beanvalidation]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>在线资源</tag>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线书籍（文档）]]></title>
    <url>%2F2018%2F%E5%9C%A8%E7%BA%BF%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[官方git（中文） Chrome扩展及应用开发 Google Java Style Maven by Example Java设计模式]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>书籍推荐</tag>
        <tag>文档推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源许可协议]]></title>
    <url>%2F2018%2F%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[GNU GPL（GNU General Public License，GNU通用公共许可证）：只要软件中包含了遵循GPL协议的产品或代码，该软件就必须也遵循GPL许可协议且开源、免费，因此这个协议并不适合商用软件。遵循该协议的开源软件数量极其庞大，包括Linux系统在内的大多数的开源软件都是基于这个协议的。GPL开源许可协议最大的4个特点如下所示。 复制自由：允许把软件复制到任何人的电脑中，并且不限制复制的数量。 传播自由：允许软件以各种形式进行传播。 收费传播：允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的；因此，一般来讲，开源软件都是通过为用户提供有偿服务的形式来盈利的。 修改自由：允许开发人员增加或删除软件的功能，但软件修改后必须依然基于GPL许可协议授权。 BSD（Berkeley Software Distribution，伯克利软件发布版）许可协议： 用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面3个条件。 如果再发布的软件中包含源代码，则源代码必须继续遵循BSD许可协议。 如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了BSD协议。 不允许用原始软件的名字、作者名字或机构名称进行市场推广。 Apache许可证版本（Apache License Version）许可协议： 在为开发人员提供版权及专利许可的同时，允许用户拥有修改代码及再发布的自由。该许可协议适用于商业软件，现在热门的Hadoop、Apache HTTP Server、MongoDB等项目都是基于该许可协议研发的，程序开发人员在开发遵循该协议的软件时，要严格遵守下面的4个条件。 该软件及其衍生品必须继续使用Apache许可协议。 如果修改了程序源代码，需要在文档中进行声明。 若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息。 如果再发布的软件中有声明文件，则需在此文件中标注Apache许可协议及其他许可协议。 MPL（Mozilla Public License，Mozilla公共许可）许可协议：相较于GPL许可协议，MPL更加注重对开发者的源代码需求和收益之间的平衡。 MIT（Massachusetts Institute of Technology）许可协议：目前限制最少的开源许可协议之一，只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，因此普遍被商业软件所使用。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>开源许可协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git改变已经提交作者信息]]></title>
    <url>%2F2018%2Fgit%E6%94%B9%E5%8F%98%E5%B7%B2%E7%BB%8F%E6%8F%90%E4%BA%A4%E4%BD%9C%E8%80%85%2F</url>
    <content type="text"><![CDATA[123456789$ git filter-branch --commit-filter ' if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ]; then GIT_AUTHOR_NAME="Scott Chacon"; GIT_AUTHOR_EMAIL="schacon@example.com"; git commit-tree "$@"; else git commit-tree "$@"; fi' HEAD]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[劝学]]></title>
    <url>%2F2018%2F%E5%8A%9D%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[荀子 君子曰：学不可以已。青，取之于蓝，而青于蓝；冰，水为之，而寒于水。木直中绳，輮以为轮，其曲中规，虽有槁暴，不复挺者，輮使之然也。故木受绳则直，金就砺则利，君子博学而日参省乎己，则知明而行无过矣。吾尝终日而思矣，不如须臾之所学也。吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。 积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。]]></content>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[师说]]></title>
    <url>%2F2018%2F2018-10-10-%E5%B8%88%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[唐-韩愈 古之学者必有师。师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师,其为惑也终不解矣。生乎吾前，其闻道也固先乎吾，吾从而师之；生乎吾后，其闻道也亦先乎吾，吾从而师之。吾师道也，夫庸知其年之先后生于吾乎？是故无贵无贱，无长无少，道之所存，师之所存也。嗟乎！师道之不传也久矣！欲人之无惑也难矣！古之圣人，其出人也远矣，犹且从师而问焉；今之众人，其下圣人也亦远矣，而耻学于师。是故圣益圣，愚益愚。圣人之所以为圣，愚人之所以为愚，其皆出于此乎?爱其子，择师而教之；于其身也，则耻师焉，惑矣。彼童子之师，授之书而习其句读者，非吾所谓传其道解其惑者也。句读之不知，惑之不解，或师焉，或不焉，小学而大遗，吾未见其明也。巫医乐师百工之人，不耻相师。士大夫之族，曰师曰弟子云者，则群聚而笑之。问之，则曰：“彼与彼年相若也，道相似也，位卑则足羞，官盛则近谀。”呜呼！师道之不复,可知矣。巫医乐师百工之人，君子不齿，今其智乃反不能及，其可怪也欤！ 圣人无常师。孔子师郯子、苌弘、师襄、老聃。郯子之徒，其贤不及孔子。孔子曰：“三人行，则必有我师”。是故弟子不必不如师，师不必贤于弟子。闻道有先后，术业有专攻，如是而已。 李氏子蟠，年十七，好古文，六艺经传皆通习之，不拘于时，学于余。余嘉其能行古道，作《师说》以贻之。]]></content>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OO 思想]]></title>
    <url>%2F2018%2F2018-10-10-OO-mind%2F</url>
    <content type="text"><![CDATA[整理总结 三大特性封装软件对象包括状态和相关行为。 方法对的内部状态进行操作，并作为对象通信的主要机制。 隐藏内部状态并要求通过对象的方法执行所有交互称为数据封装 - 面向对象编程的基本原则。 好处： 模块化：可以独立于其他对象的源码。 信息隐藏：内部实现的细节隐藏于外部。 代码重用：如果对象已存在，则可以重用。 可插拔性和调试简易性：如果某个对象有问题，只需将其从应用程序中删除，然后插入另一个对象作为替代。这类似于现实世界中的机械问题：如果螺栓断裂，更换它就行，不用换整个机器。 继承在Java语言中，类可以从其他类派生，从而继承字段和方法。 子类从其超类继承（这里的继承要理解为拷贝）所有成员（字段，方法和嵌套类）。构造函数不是成员，它们不会类继承，但可以从子类调用。 继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。 可以在子类中执行的操作 子类继承所有公共成员和受保护成员。如果子类与父类在同一个包中，它还继承父类包私有成员。 下面是一些注意点： 子类中声明同名字段，会隐藏父类字段（不推荐）。 子类中编写一个新的静态方法，与父类具有相同的签名，会实现隐藏。 子类中编写一个新实例方法，与父类具有相同的签名，会实现覆盖。 子类构造函数，它可以隐式地或使用关键字来调用父类的构造函数。 父类私有域 子类不继承父类的private成员。 嵌套类可以访问其封闭类的所有私有成员 - 包括字段和方法。于是，子类继承的嵌套类可以间接访问超类的所有私有成员。 @see code 多态 Java虚拟机（JVM）为每个变量引用的对象调用适当的方法。它不会调用声明类型的方法。此行为称为虚方法调用。 多态的三个条件： 继承 覆盖（重写） 向上转型 @see code 抽象的一些tip抽象类与接口 抽象类与接口类似，都无法实例化。但是，使用抽象类，可以声明非静态和非final的字段，并定义public，protected和private方法。使用接口，所有字段都自动为public，static和final，所有方法（作为默认方法）都是公共的。此外，只能扩展一个类，而可以实现多个接口。 使用哪个？ 抽象类： 公用的方法或字段，或者需要除public之外的访问修饰符（例如protected和private）。 声明非静态或非最终字段 接口： 不相关的类会实现，代表特性。如，接口 Comparable以及 Cloneable 指定特定数据类型的行为，但不关心谁实现。 多重继承。 JDK中的抽象类的示例 AbstractMap是集合框架的一部分。它的子类（包括HashMap，TreeMap，和ConcurrentHashMap）共享许多方法（包括get，put，isEmpty，containsKey，和containsValue）。 HashMap实现了接口Serializable，Cloneable和Map&lt;K, V&gt;。通过阅读接口列表，可以推断出HashMap（可以克隆的）实例是可序列化的（这意味着它可以转换为字节流 ），并具有Map的功能。 对象关系这里简单讲下uml里的对象关系，复杂设计可能会用到这些概念。 泛化关系 (Generalization)用来描述继承关系，在 Java 中使用 extends 关键字。 实现关系 (Realization)用来实现一个接口，在 Java 中使用 implement 关键字。 聚合关系 (Aggregation)表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。 组合关系 (Composition)和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。 关联关系 (Association)表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。 依赖关系 (Dependency)和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式： A 类是 B 类方法的局部变量； A 类是 B 类方法当中的一个参数； A 类向 B 类发送消息，从而影响 B 类发生变化。 设计理念Steve Smith在微软TechED 上有个SOLIDify Your ASP.NET MVC的讲座, 很好的解释了SOLID原则。 SOLID（稳固的） 简写 全拼 中文翻译 SRP The Single Responsibility Principle 单一责任原则 OCP The Open Closed Principle 开放封闭原则 LSP The Liskov Substitution Principle 里氏替换原则 ISP The Interface Segregation Principle 接口分离原则 DIP The Dependency Inversion Principle 依赖倒置原则 1. 单一责任原则 修改一个类的原因应该只有一个。 换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。 如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。 @see java.util.Map，java.util.Collection 2. 开放封闭原则 类应该对扩展开放，对修改关闭。 在穿外套时不需要开胸手术。 扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。 符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。 @see java.lang.Iterable 3. 里氏替换原则 子类对象必须能够替换掉所有父类对象。 如果它看起来像一只鸭子，像鸭子一样嘎嘎叫，但需要电池——你可能有了错误的抽象。 继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。 如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。 @see java.util.ArrayList，和其他java集合类 4. 接口分离原则 不应该强迫客户依赖于它们不用的方法。使用多个专门的接口比使用单一的总接口总要好。 你要我插到哪个接口？ 因此使用多个专门的接口比使用单一的总接口要好。 @see java.util.Map，java.util.Collection 5. 依赖倒置原则 底层模块不应该依赖于上层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。 你会把一盏灯直接焊接到墙上的电线上吗？ 底层模块包含一个应用程序中重要的策略选择和业务模块；如果底层模块依赖于上层模块，那么上层模块的改动就会直接影响到底层模块，从而迫使底层模块也需要改动。 @see java.util.Map，java.util.Collection 其他常见原则除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。 简写 全拼 中文翻译 LOD The Law of Demeter 迪米特法则 CRP The Composite Reuse Principle 合成复用原则 CCP The Common Closure Principle 共同封闭原则 SAP The Stable Abstractions Principle 稳定抽象原则 SDP The Stable Dependencies Principle 稳定依赖原则 1. 迪米特法则迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解。 尽量调用他们的公开方法。 2. 合成复用原则尽量使用对象组合，而不是通过继承来达到复用的目的。这样可以解耦。 3. 共同封闭原则一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。 所以按业务区分包也是不错的选择，可以较充分包可见性。 4. 稳定抽象原则最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。 @see javax.validation.validation-api 5. 稳定依赖原则包之间的依赖关系都应该是稳定向依赖，包要依赖的包要比自己更具有稳定性。 所以尽量依赖jdk，再就是一些广泛使用的第三方框架，后续是小众框架。 软件设计通用原则 不做重复的事（DRY，Don’t Repeat Yourself） 在一定范围内抽象功能，不要重复。 降低可管理单元复杂度的一个基本策略就是将他们拆解成更小的单元。 违反DRY原则的解决方案通常被称为WET，指代“write everything twice”。 spring文档里面经常提到这个原则。 有需要可以尝试第三方工具如 apache common utils、guava等。 保持简单直接（KISS，Keep it Simple Stupid） 坚持简约原则，避免不必要的复杂化。 对外的接口尽量简洁明了。 这样上游和用户可以减少疑问，也降低沟通成本。 把一个事情搞复杂是一件简单的事，但要把一个复杂的事变简单，这是一件复杂的事。 你不需要它(YAGNI，You Ain’t Gonna Need It) 这是”极限编程”提倡的原则，指的是你自以为有用的功能，实际上都是用不到的。因此，除了最核心（需要）的功能，其他功能一概不要部署，这样可以大大加快开发。 它背后的指导思想，就是尽可能快、尽可能简单地让软件运行起来（do the simplest thing that could possibly work） 就是避免过度设计。 使用2次以上可以考虑抽取功能。 批判性思考[美] Kirk Knoernschild 在“java应用架构设计：模块化模式与OSGi”提到一个悖论： 重用/可用悖论（重用悖论） 最大化重用会使得可用复杂化。 总体而言，软件模块的可重用性越高，这个模块使用起来就越困难。 所以，软件设计要在重用和可用中找到一个折衷点。 spring项目其实做了很好的折衷： 它分成了几个块： 核心技术：依赖注入，事件，资源，i18n，验证，数据绑定，类型转换，SpEL，AOP。 测试：模拟对象，TestContext框架，Spring MVC测试，WebTestClient。 数据访问：事务，DAO支持，JDBC，ORM，编组XML。 Spring MVC和 Spring WebFlux Web框架。 集成：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。 语言：Kotlin，Groovy，动态语言。 我们可以按需依赖其中几个而不必依赖所有的。spring没有划分的非常细，它划了几个通用的包，使得使用者易于使用，也达到了不错的重用效果。 后记主要是记住OO3大特性和OO5大原则，在遵守原则的同时可以尽量运用特性进行编程简化。 重用可用悖论也是我们要思考的问题，他说明了了软件设计中模块（代码）粒度需要折衷。 而运用这些原则和特性的目的是实现可读、可维护、可复用、易用的代码，模块，项目和业务系统。 其他原则也可以适时适度的参考。 codecode 参考 https://crossoverjie.top/JCSprout/#/ 其他]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>oom</tag>
      </tags>
  </entry>
</search>
