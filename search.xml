<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[元日]]></title>
    <url>%2F2019%2F%E5%85%83%E6%97%A5%2F</url>
    <content type="text"><![CDATA[宋：王安石爆竹声中一岁除，春风送暖入屠苏。千门万户曈曈日，总把新桃换旧符。]]></content>
  </entry>
  <entry>
    <title><![CDATA[始得西山宴游记]]></title>
    <url>%2F2019%2F%E5%A7%8B%E5%BE%97%E8%A5%BF%E5%B1%B1%E5%AE%B4%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[唐-柳宗元 自余为僇人，居是州，恒惴栗。其隟也，则施施而行，漫漫而游。日与其徒上高山，入深林，穷回溪，幽泉怪石，无远不到。到则披草而坐，倾壶而醉。醉则更相枕以卧，卧而梦。意有所极，梦亦同趣。觉而起，起而归；以为凡是州之山水有异态者，皆我有也，而未始知西山之怪特。 今年九月二十八日，因坐法华西亭，望西山，始指异之。遂命仆人过湘江，缘染溪，斫榛莽，焚茅茷，穷山之高而止。攀援而登，箕踞而遨，则凡数州之土壤，皆在衽席之下。其高下之势，岈然洼然，若垤若穴，尺寸千里，攒蹙累积，莫得遁隐。萦青缭白，外与天际，四望如一。然后知是山之特立，不与培塿为类。悠悠乎与颢气俱，而莫得其涯；洋洋乎与造物者游，而不知其所穷。引觞满酌，颓然就醉，不知日之入。苍然暮色，自远而至，至无所见，而犹不欲归。心凝形释，与万化冥合。然后知吾向之未始游，游于是乎始。故为之文以志。是岁，元和四年也。]]></content>
      <tags>
        <tag>古文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary]]></title>
    <url>%2F2018%2Fdiary%2F</url>
    <content type="text"><![CDATA[杭州又下雪了，2018年的最后一场雪~ ヾ(･ω･`｡)]]></content>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雨霖铃·寒蝉凄切]]></title>
    <url>%2F2018%2F%E9%9B%A8%E9%9C%96%E9%93%83%C2%B7%E5%AF%92%E8%9D%89%E5%87%84%E5%88%87%2F</url>
    <content type="text"><![CDATA[宋代：柳永 寒蝉凄切，对长亭晚，骤雨初歇。都门帐饮无绪，留恋处，兰舟催发。执手相看泪眼，竟无语凝噎。念去去，千里烟波，暮霭沉沉楚天阔。 多情自古伤离别，更那堪，冷落清秋节！今宵酒醒何处？杨柳岸，晓风残月。此去经年，应是良辰好景虚设。便纵有千种风情，更与何人说？]]></content>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线资源]]></title>
    <url>%2F2018%2Fonline-resource%2F</url>
    <content type="text"><![CDATA[VisuAlgo(数据结构和算法动态可视化) jsr beanvalidation]]></content>
      <tags>
        <tag>在线资源</tag>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线书籍推荐]]></title>
    <url>%2F2018%2F%E5%9C%A8%E7%BA%BF%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[官方git（中文） Chrome扩展及应用开发]]></content>
      <tags>
        <tag>git</tag>
        <tag>书籍推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式手册]]></title>
    <url>%2F2018%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[div.main_div { font-family: sans-serif; font-size: 1em; } table.wikitable { background: none repeat scroll 0 0 #F9F9F9; border: 1px solid #AAAAAA; border-collapse: collapse; color: black; } .wikitable th, .wikitable td { border: 1px solid #AAAAAA; padding: 0.2em; } .wikitable th { background: none repeat scroll 0 0 #F2F2F2; text-align: center; } p { line-height: 1.5em; margin: 0.4em 0 0.5em; } h2{ margin:0; font-weight:normal;} 表达式 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\\”匹配“\”而“\(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.|\n)”的模式。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。 x|y 匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \B 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \cx 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \d 匹配一个数字字符。等价于[0-9]。 \D 匹配一个非数字字符。等价于[^0-9]。 \f 匹配一个换页符。等价于\x0c和\cL。 \n 匹配一个换行符。等价于\x0a和\cJ。 \r 匹配一个回车符。等价于\x0d和\cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于[^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于\x09和\cI。 \v 匹配一个垂直制表符。等价于\x0b和\cK。 \w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。. \num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。 \nml 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（&copy;）。 常用正则表达式 用户名 /^[a-z0-9_-]{3,16}$/ 密码 /^[a-z0-9_-]{6,18}$/ 十六进制值 /^#?([a-f0-9]{6}|[a-f0-9]{3})$/ 电子邮箱 /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/ /^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$/ URL /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/ IP 地址 /((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)//^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/ HTML 标签 /^&lt;([a-z]+)([^&lt;]+)*(?:&gt;(.*)&lt;\/\1&gt;|\s+\/&gt;)$/ 删除代码\\注释 (?&lt;!http:|\S)//.*$ Unicode编码中的汉字范围 /^[\u2E80-\u9FFF]+$/]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源许可协议]]></title>
    <url>%2F2018%2F%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[GNU GPL（GNU General Public License，GNU通用公共许可证）：只要软件中包含了遵循GPL协议的产品或代码，该软件就必须也遵循GPL许可协议且开源、免费，因此这个协议并不适合商用软件。遵循该协议的开源软件数量极其庞大，包括Linux系统在内的大多数的开源软件都是基于这个协议的。GPL开源许可协议最大的4个特点如下所示。 复制自由：允许把软件复制到任何人的电脑中，并且不限制复制的数量。 传播自由：允许软件以各种形式进行传播。 收费传播：允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的；因此，一般来讲，开源软件都是通过为用户提供有偿服务的形式来盈利的。 修改自由：允许开发人员增加或删除软件的功能，但软件修改后必须依然基于GPL许可协议授权。 BSD（Berkeley Software Distribution，伯克利软件发布版）许可协议： 用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面3个条件。 如果再发布的软件中包含源代码，则源代码必须继续遵循BSD许可协议。 如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了BSD协议。 不允许用原始软件的名字、作者名字或机构名称进行市场推广。 Apache许可证版本（Apache License Version）许可协议： 在为开发人员提供版权及专利许可的同时，允许用户拥有修改代码及再发布的自由。该许可协议适用于商业软件，现在热门的Hadoop、Apache HTTP Server、MongoDB等项目都是基于该许可协议研发的，程序开发人员在开发遵循该协议的软件时，要严格遵守下面的4个条件。 该软件及其衍生品必须继续使用Apache许可协议。 如果修改了程序源代码，需要在文档中进行声明。 若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息。 如果再发布的软件中有声明文件，则需在此文件中标注Apache许可协议及其他许可协议。 MPL（Mozilla Public License，Mozilla公共许可）许可协议：相较于GPL许可协议，MPL更加注重对开发者的源代码需求和收益之间的平衡。 MIT（Massachusetts Institute of Technology）许可协议：目前限制最少的开源许可协议之一，只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，因此普遍被商业软件所使用。]]></content>
      <tags>
        <tag>开源许可协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git改变已经提交作者信息]]></title>
    <url>%2F2018%2Fgit%E6%94%B9%E5%8F%98%E5%B7%B2%E7%BB%8F%E6%8F%90%E4%BA%A4%E4%BD%9C%E8%80%85%2F</url>
    <content type="text"><![CDATA[打开终端（Mac 或 Linux 用户）或命令行（Windows 用户）。 创建一个你的 repo 的全新裸 clone （repo.git 替换为你的项目，下同） 12git clone --bare https://github.com/user/repo.gitcd repo.git 复制粘贴脚本，并根据你的信息修改以下变量： OLD_EMAIL CORRECT_NAME CORRECT_EMAIL 脚本： 12345678910111213141516171819#!/bin/shgit filter-branch --env-filter 'OLD_EMAIL="your-old-email@example.com"CORRECT_NAME="Your Correct Name"CORRECT_EMAIL="your-correct-email@example.com"if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]then export GIT_COMMITTER_NAME="$CORRECT_NAME" export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"fiif [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]then export GIT_AUTHOR_NAME="$CORRECT_NAME" export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"fi ' --tag-name-filter cat -- --branches --tags 按 Enter 执行脚本。 查看新 Git 历史有没有错误。 把正确历史 push 到 Github：（push 有困难时记得修改 DNS 或者搭梯子） 1git push --force --tags origin 'refs/heads/*' 清除临时 clone。 12cd ..rm -rf repo.git]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蝶恋花-春景]]></title>
    <url>%2F2018%2F%E8%9D%B6%E6%81%8B%E8%8A%B1-%E6%98%A5%E6%99%AF%2F</url>
    <content type="text"><![CDATA[宋-苏轼 花褪残红青杏小，燕子飞时，绿水人家绕。 枝上柳绵吹又少，天涯何处无芳草！ 墙里秋千墙外道，墙外行人，墙里佳人笑。笑渐不闻声渐悄，多情却被无情恼。]]></content>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一剪梅·舟过吴江]]></title>
    <url>%2F2018%2F%E4%B8%80%E5%89%AA%E6%A2%85%C2%B7%E8%88%9F%E8%BF%87%E5%90%B4%E6%B1%9F%2F</url>
    <content type="text"><![CDATA[宋末-蒋捷 一片春愁待酒浇。江上舟摇，楼上帘招。秋娘渡与泰娘桥，风又飘飘，雨又萧萧。 何日归家洗客袍？银字笙调，心字香烧。流光容易把人抛，红了樱桃，绿了芭蕉。]]></content>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[劝学]]></title>
    <url>%2F2018%2F%E5%8A%9D%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[荀子 君子曰：学不可以已。青，取之于蓝，而青于蓝；冰，水为之，而寒于水。木直中绳，輮以为轮，其曲中规，虽有槁暴，不复挺者，輮使之然也。故木受绳则直，金就砺则利，君子博学而日参省乎己，则知明而行无过矣。吾尝终日而思矣，不如须臾之所学也。吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。 积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。]]></content>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片分享]]></title>
    <url>%2F2018%2F%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[师说]]></title>
    <url>%2F2018%2F2018-10-10-%E5%B8%88%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[唐-韩愈 古之学者必有师。师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师,其为惑也终不解矣。生乎吾前，其闻道也固先乎吾，吾从而师之；生乎吾后，其闻道也亦先乎吾，吾从而师之。吾师道也，夫庸知其年之先后生于吾乎？是故无贵无贱，无长无少，道之所存，师之所存也。嗟乎！师道之不传也久矣！欲人之无惑也难矣！古之圣人，其出人也远矣，犹且从师而问焉；今之众人，其下圣人也亦远矣，而耻学于师。是故圣益圣，愚益愚。圣人之所以为圣，愚人之所以为愚，其皆出于此乎?爱其子，择师而教之；于其身也，则耻师焉，惑矣。彼童子之师，授之书而习其句读者，非吾所谓传其道解其惑者也。句读之不知，惑之不解，或师焉，或不焉，小学而大遗，吾未见其明也。巫医乐师百工之人，不耻相师。士大夫之族，曰师曰弟子云者，则群聚而笑之。问之，则曰：“彼与彼年相若也，道相似也，位卑则足羞，官盛则近谀。”呜呼！师道之不复,可知矣。巫医乐师百工之人，君子不齿，今其智乃反不能及，其可怪也欤！ 圣人无常师。孔子师郯子、苌弘、师襄、老聃。郯子之徒，其贤不及孔子。孔子曰：“三人行，则必有我师”。是故弟子不必不如师，师不必贤于弟子。闻道有先后，术业有专攻，如是而已。 李氏子蟠，年十七，好古文，六艺经传皆通习之，不拘于时，学于余。余嘉其能行古道，作《师说》以贻之。]]></content>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OO 思想]]></title>
    <url>%2F2018%2F2018-10-10-OO-mind%2F</url>
    <content type="text"><![CDATA[原创整理与编写，转载请注明出处 三大特性封装软件对象包括状态和相关行为。 方法对的内部状态进行操作，并作为对象通信的主要机制。 隐藏内部状态并要求通过对象的方法执行所有交互称为数据封装 - 面向对象编程的基本原则。 好处： 模块化：可以独立于其他对象的源码。 信息隐藏：内部实现的细节隐藏于外部。 代码重用：如果对象已存在，则可以重用。 可插拔性和调试简易性：如果某个对象有问题，只需将其从应用程序中删除，然后插入另一个对象作为替代。这类似于现实世界中的机械问题：如果螺栓断裂，更换它就行，不用换整个机器。 继承 在Java语言中，类可以从其他类派生，从而继承字段和方法。 子类从其超类继承（这里的继承要理解为拷贝）所有成员（字段，方法和嵌套类）。构造函数不是成员，它们不会类继承，但可以从子类调用。 继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。 可以在子类中执行的操作 子类继承所有公共成员和受保护成员。如果子类与父类在同一个包中，它还继承父类包私有成员。 下面是一些注意点： 子类中声明同名字段，会隐藏父类字段（不推荐）。 子类中编写一个新的静态方法，与父类具有相同的签名，会实现隐藏。 子类中编写一个新实例方法，与父类具有相同的签名，会实现覆盖。 子类构造函数，它可以隐式地或使用关键字来调用父类的构造函数。 父类私有域 子类不继承父类的private成员。 嵌套类可以访问其封闭类的所有私有成员 - 包括字段和方法。于是，子类继承的嵌套类可以间接访问超类的所有私有成员。 @see code 多态 Java虚拟机（JVM）为每个变量引用的对象调用适当的方法。它不会调用声明类型的方法。此行为称为虚方法调用。 多态的三个条件： 继承 覆盖（重写） 向上转型 @see code 抽象的一些tip抽象类与接口 抽象类与接口类似，都无法实例化。但是，使用抽象类，可以声明非静态和非final的字段，并定义public，protected和private方法。使用接口，所有字段都自动为public，static和final，所有方法（作为默认方法）都是公共的。此外，只能扩展一个类，而可以实现多个接口。 使用哪个？ 抽象类： 公用的方法或字段，或者需要除public之外的访问修饰符（例如protected和private）。 声明非静态或非最终字段 接口： 不相关的类会实现，代表特性。如，接口 Comparable以及 Cloneable 指定特定数据类型的行为，但不关心谁实现。 多重继承。 JDK中的抽象类的示例 AbstractMap是集合框架的一部分。它的子类（包括HashMap，TreeMap，和ConcurrentHashMap）共享许多方法（包括get，put，isEmpty，containsKey，和containsValue）。 HashMap实现了接口Serializable，Cloneable和Map&lt;K, V&gt;。通过阅读接口列表，可以推断出HashMap（可以克隆的）实例是可序列化的（这意味着它可以转换为字节流 ），并具有Map的功能。 对象关系这里简单讲下uml里的对象关系，复杂设计可能会用到这些概念。 泛化关系 (Generalization)用来描述继承关系，在 Java 中使用 extends 关键字。 实现关系 (Realization)用来实现一个接口，在 Java 中使用 implement 关键字。 聚合关系 (Aggregation)表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。 组合关系 (Composition)和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。 关联关系 (Association)表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。 依赖关系 (Dependency)和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式： A 类是 B 类方法的局部变量； A 类是 B 类方法当中的一个参数； A 类向 B 类发送消息，从而影响 B 类发生变化。 设计理念Steve Smith在微软TechED 上有个SOLIDify Your ASP.NET MVC的讲座, 很好的解释了SOLID原则。 SOLID（稳固的） 简写 全拼 中文翻译 SRP The Single Responsibility Principle 单一责任原则 OCP The Open Closed Principle 开放封闭原则 LSP The Liskov Substitution Principle 里氏替换原则 ISP The Interface Segregation Principle 接口分离原则 DIP The Dependency Inversion Principle 依赖倒置原则 1. 单一责任原则 修改一个类的原因应该只有一个。 换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。 如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。 @see java.util.Map，java.util.Collection 2. 开放封闭原则 类应该对扩展开放，对修改关闭。 在穿外套时不需要开胸手术。 扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。 符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。 @see java.lang.Iterable 3. 里氏替换原则 子类对象必须能够替换掉所有父类对象。 如果它看起来像一只鸭子，像鸭子一样嘎嘎叫，但需要电池——你可能有了错误的抽象。 继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。 如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。 @see java.util.ArrayList，和其他java集合类 4. 接口分离原则 不应该强迫客户依赖于它们不用的方法。使用多个专门的接口比使用单一的总接口总要好。 你要我插到哪个接口？ 因此使用多个专门的接口比使用单一的总接口要好。 @see java.util.Map，java.util.Collection 5. 依赖倒置原则 底层模块不应该依赖于上层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。 你会把一盏灯直接焊接到墙上的电线上吗？ 底层模块包含一个应用程序中重要的策略选择和业务模块；如果底层模块依赖于上层模块，那么上层模块的改动就会直接影响到底层模块，从而迫使底层模块也需要改动。 @see java.util.Map，java.util.Collection 其他常见原则除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。 简写 全拼 中文翻译 LOD The Law of Demeter 迪米特法则 CRP The Composite Reuse Principle 合成复用原则 CCP The Common Closure Principle 共同封闭原则 SAP The Stable Abstractions Principle 稳定抽象原则 SDP The Stable Dependencies Principle 稳定依赖原则 1. 迪米特法则迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解。 尽量调用他们的公开方法。 2. 合成复用原则尽量使用对象组合，而不是通过继承来达到复用的目的。这样可以解耦。 3. 共同封闭原则一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。 所以按业务区分包也是不错的选择，可以较充分包可见性。 4. 稳定抽象原则最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。 @see javax.validation.validation-api 5. 稳定依赖原则包之间的依赖关系都应该是稳定向依赖，包要依赖的包要比自己更具有稳定性。 所以尽量依赖jdk，再就是一些广泛使用的第三方框架，后续是小众框架。 软件设计通用原则 不做重复的事（DRY，Don’t Repeat Yourself） 在一定范围内抽象功能，不要重复。 降低可管理单元复杂度的一个基本策略就是将他们拆解成更小的单元。 违反DRY原则的解决方案通常被称为WET，指代“write everything twice”。 spring文档里面经常提到这个原则。 有需要可以尝试第三方工具如 apache common utils、guava等。 保持简单直接（KISS，Keep it Simple Stupid） 坚持简约原则，避免不必要的复杂化。 对外的接口尽量简洁明了。 这样上游和用户可以减少疑问，也降低沟通成本。 把一个事情搞复杂是一件简单的事，但要把一个复杂的事变简单，这是一件复杂的事。 你不需要它(YAGNI，You Ain’t Gonna Need It) 这是”极限编程”提倡的原则，指的是你自以为有用的功能，实际上都是用不到的。因此，除了最核心（需要）的功能，其他功能一概不要部署，这样可以大大加快开发。 它背后的指导思想，就是尽可能快、尽可能简单地让软件运行起来（do the simplest thing that could possibly work） 就是避免过度设计。 使用2次以上可以考虑抽取功能。 批判性思考[美] Kirk Knoernschild 在“java应用架构设计：模块化模式与OSGi”提到一个悖论： 重用/可用悖论（重用悖论） 最大化重用会使得可用复杂化。 总体而言，软件模块的可重用性越高，这个模块使用起来就越困难。 所以，软件设计要在重用和可用中找到一个折衷点。 spring项目其实做了很好的折衷： 它分成了几个块： 核心技术：依赖注入，事件，资源，i18n，验证，数据绑定，类型转换，SpEL，AOP。 测试：模拟对象，TestContext框架，Spring MVC测试，WebTestClient。 数据访问：事务，DAO支持，JDBC，ORM，编组XML。 Spring MVC和 Spring WebFlux Web框架。 集成：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。 语言：Kotlin，Groovy，动态语言。 我们可以按需依赖其中几个而不必依赖所有的。spring没有划分的非常细，它划了几个通用的包，使得使用者易于使用，也达到了不错的重用效果。 后记主要是记住OO3大特性和OO5大原则，在遵守原则的同时可以尽量运用特性进行编程简化。 重用可用悖论也是我们要思考的问题，他说明了了软件设计中模块（代码）粒度需要折衷。 而运用这些原则和特性的目的是实现可读、可维护、可复用、易用的代码，模块，项目和业务系统。 其他原则也可以适时适度的参考。 codecode —–转载请注明出处—–]]></content>
      <tags>
        <tag>java</tag>
        <tag>oom</tag>
      </tags>
  </entry>
</search>
